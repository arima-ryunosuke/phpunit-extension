<?php

# Don't touch this code. This is auto generated.

namespace ryunosuke\PHPUnit;

# constants
if (!defined("ryunosuke\\PHPUnit\\JP_ERA")) {
    /** 和暦 */
    define("ryunosuke\\PHPUnit\\JP_ERA", [
        [
            "name"  => "令和",
            "abbr"  => "R",
            "since" => 1556636400,
        ],
        [
            "name"  => "平成",
            "abbr"  => "H",
            "since" => 600188400,
        ],
        [
            "name"  => "昭和",
            "abbr"  => "S",
            "since" => -1357635600,
        ],
        [
            "name"  => "大正",
            "abbr"  => "T",
            "since" => -1812186000,
        ],
        [
            "name"  => "明治",
            "abbr"  => "M",
            "since" => -3216790800,
        ],
    ]);
}

if (!defined("ryunosuke\\PHPUnit\\TOKEN_NAME")) {
    /** parse_php 関数でトークン名変換をするか */
    define("ryunosuke\\PHPUnit\\TOKEN_NAME", 2);
}

if (!defined("ryunosuke\\PHPUnit\\SI_UNITS")) {
    /** SI 接頭辞 */
    define("ryunosuke\\PHPUnit\\SI_UNITS", [
        -8 => ["y"],
        -7 => ["z"],
        -6 => ["a"],
        -5 => ["f"],
        -4 => ["p"],
        -3 => ["n"],
        -2 => ["u", "μ", "µ"],
        -1 => ["m"],
        0  => [],
        1  => ["k", "K"],
        2  => ["M"],
        3  => ["G"],
        4  => ["T"],
        5  => ["P"],
        6  => ["E"],
        7  => ["Z"],
        8  => ["Y"],
    ]);
}


# functions
if (!isset($excluded_functions["arrayize"]) && (!function_exists("ryunosuke\\PHPUnit\\arrayize") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\arrayize"))->isInternal()))) {
    /**
     * 引数の配列を生成する。
     *
     * 配列以外を渡すと配列化されて追加される。
     * 連想配列は未対応。あくまで普通の配列化のみ。
     * iterable や Traversable は考慮せずあくまで「配列」としてチェックする。
     *
     * Example:
     * ```php
     * that(arrayize(1, 2, 3))->isSame([1, 2, 3]);
     * that(arrayize([1], [2], [3]))->isSame([1, 2, 3]);
     * $object = new \stdClass();
     * that(arrayize($object, false, [1, 2, 3]))->isSame([$object, false, 1, 2, 3]);
     * ```
     *
     * @param mixed ...$variadic 生成する要素（可変引数）
     * @return array 引数を配列化したもの
     */
    function arrayize(...$variadic)
    {
        $result = [];
        foreach ($variadic as $arg) {
            if (!is_array($arg)) {
                $result[] = $arg;
            }
            elseif (!is_hasharray($arg)) {
                $result = array_merge($result, $arg);
            }
            else {
                $result += $arg;
            }
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\arrayize") && !defined("ryunosuke\\PHPUnit\\arrayize")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\arrayize", "ryunosuke\\PHPUnit\\arrayize");
}

if (!isset($excluded_functions["is_hasharray"]) && (!function_exists("ryunosuke\\PHPUnit\\is_hasharray") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\is_hasharray"))->isInternal()))) {
    /**
     * 配列が連想配列か調べる
     *
     * 空の配列は普通の配列とみなす。
     *
     * Example:
     * ```php
     * that(is_hasharray([]))->isFalse();
     * that(is_hasharray([1, 2, 3]))->isFalse();
     * that(is_hasharray(['x' => 'X']))->isTrue();
     * ```
     *
     * @param array $array 調べる配列
     * @return bool 連想配列なら true
     */
    function is_hasharray(array $array)
    {
        $i = 0;
        foreach ($array as $k => $dummy) {
            if ($k !== $i++) {
                return true;
            }
        }
        return false;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\is_hasharray") && !defined("ryunosuke\\PHPUnit\\is_hasharray")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\is_hasharray", "ryunosuke\\PHPUnit\\is_hasharray");
}

if (!isset($excluded_functions["last_key"]) && (!function_exists("ryunosuke\\PHPUnit\\last_key") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\last_key"))->isInternal()))) {
    /**
     * 配列の最後のキーを返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(last_key(['a', 'b', 'c']))->isSame(2);
     * that(last_key([], 999))->isSame(999);
     * ```
     *
     * @param iterable $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 最後のキー
     */
    function last_key($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        /** @noinspection PhpUnusedLocalVariableInspection */
        [$k, $v] = last_keyvalue($array);
        return $k;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\last_key") && !defined("ryunosuke\\PHPUnit\\last_key")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\last_key", "ryunosuke\\PHPUnit\\last_key");
}

if (!isset($excluded_functions["last_value"]) && (!function_exists("ryunosuke\\PHPUnit\\last_value") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\last_value"))->isInternal()))) {
    /**
     * 配列の最後の値を返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(last_value(['a', 'b', 'c']))->isSame('c');
     * that(last_value([], 999))->isSame(999);
     * ```
     *
     * @param iterable $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 最後の値
     */
    function last_value($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        /** @noinspection PhpUnusedLocalVariableInspection */
        [$k, $v] = last_keyvalue($array);
        return $v;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\last_value") && !defined("ryunosuke\\PHPUnit\\last_value")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\last_value", "ryunosuke\\PHPUnit\\last_value");
}

if (!isset($excluded_functions["last_keyvalue"]) && (!function_exists("ryunosuke\\PHPUnit\\last_keyvalue") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\last_keyvalue"))->isInternal()))) {
    /**
     * 配列の最後のキー/値ペアをタプルで返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(last_keyvalue(['a', 'b', 'c']))->isSame([2, 'c']);
     * that(last_keyvalue([], 999))->isSame(999);
     * ```
     *
     * @param iterable $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return array [最後のキー, 最後の値]
     */
    function last_keyvalue($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        if (is_array($array)) {
            $k = array_key_last($array);
            return [$k, $array[$k]];
        }
        /** @noinspection PhpStatementHasEmptyBodyInspection */
        foreach ($array as $k => $v) {
            // dummy
        }
        // $k がセットされてるなら「ループが最低でも1度回った（≠空）」とみなせる
        if (isset($k)) {
            /** @noinspection PhpUndefinedVariableInspection */
            return [$k, $v];
        }
        return $default;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\last_keyvalue") && !defined("ryunosuke\\PHPUnit\\last_keyvalue")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\last_keyvalue", "ryunosuke\\PHPUnit\\last_keyvalue");
}

if (!isset($excluded_functions["next_key"]) && (!function_exists("ryunosuke\\PHPUnit\\next_key") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\next_key"))->isInternal()))) {
    /**
     * 配列の指定キーの次のキーを返す
     *
     * $key が最後のキーだった場合は null を返す。
     * $key が存在しない場合は false を返す。
     * $key が未指定だと「次に生成されるキー」（$array[]='hoge' で生成されるキー）を返す。
     *
     * $array[] = 'hoge' で作成されるキーには完全準拠しない（標準は unset すると結構乱れる）。公式マニュアルを参照。
     *
     * Example:
     * ```php
     * $array = [9 => 9, 'a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // 'b' キーの次は 'c'
     * that(next_key($array, 'b'))->isSame('c');
     * // 'c' キーの次は無いので null
     * that(next_key($array, 'c'))->isSame(null);
     * // 'x' キーはそもそも存在しないので false
     * that(next_key($array, 'x'))->isSame(false);
     * // 次に生成されるキーは 10
     * that(next_key($array, null))->isSame(10);
     * ```
     *
     * @param array $array 対象配列
     * @param string|int|null $key 調べるキー
     * @return string|int|bool|null $key の次のキー
     */
    function next_key($array, $key = null)
    {
        $keynull = $key === null;
        $key = (string) $key;
        $current = false;
        $max = -1;
        foreach ($array as $k => $v) {
            if ($current !== false) {
                return $k;
            }
            if ($key === (string) $k) {
                $current = null;
            }
            if ($keynull && is_int($k) && $k > $max) {
                $max = $k;
            }
        }
        if ($keynull) {
            // PHP 4.3.0 以降は0以下にはならない
            return max(0, $max + 1);
        }
        else {
            return $current;
        }
    }
}
if (function_exists("ryunosuke\\PHPUnit\\next_key") && !defined("ryunosuke\\PHPUnit\\next_key")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\next_key", "ryunosuke\\PHPUnit\\next_key");
}

if (!isset($excluded_functions["array_explode"]) && (!function_exists("ryunosuke\\PHPUnit\\array_explode") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\array_explode"))->isInternal()))) {
    /**
     * 配列を指定条件で分割する
     *
     * 文字列の explode を更に一階層掘り下げたイメージ。
     * $condition で指定された要素は結果配列に含まれない。
     *
     * $condition にはクロージャが指定できる。クロージャの場合は true 相当を返した場合に分割要素とみなされる。
     * 引数は (値, キー)の順番。
     *
     * $limit に負数を与えると「その絶対値-1までを結合したものと残り」を返す。
     * 端的に言えば「正数を与えると後詰めでその個数で返す」「負数を与えると前詰めでその（絶対値）個数で返す」という動作になる。
     *
     * Example:
     * ```php
     * // null 要素で分割
     * that(array_explode(['a', null, 'b', 'c'], null))->isSame([['a'], [2 => 'b', 3 => 'c']]);
     * // クロージャで分割（大文字で分割）
     * that(array_explode(['a', 'B', 'c', 'D', 'e'], fn($v) => ctype_upper($v)))->isSame([['a'], [2 => 'c'], [4 => 'e']]);
     * // 負数指定
     * that(array_explode(['a', null, 'b', null, 'c'], null, -2))->isSame([[0 => 'a', 1 => null, 2 => 'b'], [4 => 'c']]);
     * ```
     *
     * @param iterable $array 対象配列
     * @param mixed $condition 分割条件
     * @param int $limit 最大分割数
     * @return array 分割された配列
     */
    function array_explode($array, $condition, $limit = \PHP_INT_MAX)
    {
        $array = arrayval($array, false);

        $limit = (int) $limit;
        if ($limit < 0) {
            // キーまで考慮するとかなりややこしくなるので富豪的にやる
            $reverse = array_explode(array_reverse($array, true), $condition, -$limit);
            $reverse = array_map(fn($v) => array_reverse($v, true), $reverse);
            return array_reverse($reverse);
        }
        // explode において 0 は 1 と等しい
        if ($limit === 0) {
            $limit = 1;
        }

        $result = [];
        $chunk = [];
        $n = -1;
        foreach ($array as $k => $v) {
            $n++;

            if ($limit === 1) {
                $chunk = array_slice($array, $n, null, true);
                break;
            }

            if ($condition instanceof \Closure) {
                $match = $condition($v, $k, $n);
            }
            else {
                $match = $condition === $v;
            }

            if ($match) {
                $limit--;
                $result[] = $chunk;
                $chunk = [];
            }
            else {
                $chunk[$k] = $v;
            }
        }
        $result[] = $chunk;
        return $result;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\array_explode") && !defined("ryunosuke\\PHPUnit\\array_explode")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\array_explode", "ryunosuke\\PHPUnit\\array_explode");
}

if (!isset($excluded_functions["array_sprintf"]) && (!function_exists("ryunosuke\\PHPUnit\\array_sprintf") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\array_sprintf"))->isInternal()))) {
    /**
     * キーと値で sprintf する
     *
     * 配列の各要素を文字列化して返すイメージ。
     * $glue を与えるとさらに implode して返す（返り値が文字列になる）。
     *
     * $format は書式文字列（$v, $k）。
     * callable を与えると sprintf ではなくコールバック処理になる（$v, $k）。
     * 省略（null）するとキーを format 文字列、値を引数として **vsprintf** する。
     *
     * Example:
     * ```php
     * $array = ['key1' => 'val1', 'key2' => 'val2'];
     * // key, value を利用した sprintf
     * that(array_sprintf($array, '%2$s=%1$s'))->isSame(['key1=val1', 'key2=val2']);
     * // 第3引数を与えるとさらに implode される
     * that(array_sprintf($array, '%2$s=%1$s', ' '))->isSame('key1=val1 key2=val2');
     * // クロージャを与えるとコールバック動作になる
     * $closure = fn($v, $k) => "$k=" . strtoupper($v);
     * that(array_sprintf($array, $closure, ' '))->isSame('key1=VAL1 key2=VAL2');
     * // 省略すると vsprintf になる
     * that(array_sprintf([
     *     'str:%s,int:%d' => ['sss', '3.14'],
     *     'single:%s'     => 'str',
     * ], null, '|'))->isSame('str:sss,int:3|single:str');
     * ```
     *
     * @param iterable $array 対象配列
     * @param string|callable|null $format 書式文字列あるいはクロージャ
     * @param ?string $glue 結合文字列。未指定時は implode しない
     * @return array|string sprintf された配列
     */
    function array_sprintf($array, $format = null, $glue = null)
    {
        if (is_callable($format)) {
            $callback = func_user_func_array($format);
        }
        elseif ($format === null) {
            $callback = fn($v, $k, $n) => vsprintf($k, is_array($v) ? $v : [$v]);
        }
        else {
            $callback = fn($v, $k, $n) => sprintf($format, $v, $k);
        }

        $result = [];
        $n = 0;
        foreach ($array as $k => $v) {
            $result[] = $callback($v, $k, $n++);
        }

        if ($glue !== null) {
            return implode($glue, $result);
        }

        return $result;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\array_sprintf") && !defined("ryunosuke\\PHPUnit\\array_sprintf")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\array_sprintf", "ryunosuke\\PHPUnit\\array_sprintf");
}

if (!isset($excluded_functions["array_unset"]) && (!function_exists("ryunosuke\\PHPUnit\\array_unset") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\array_unset"))->isInternal()))) {
    /**
     * 伏せると同時にその値を返す
     *
     * $key に配列を与えると全て伏せて配列で返す。
     * その場合、$default が活きるのは「全て無かった場合」となる。
     *
     * さらに $key が配列の場合に限り、 $default を省略すると空配列として動作する。
     *
     * 配列を与えた場合の返り値は与えた配列の順番・キーが活きる。
     * これを利用すると list の展開の利便性が上がったり、連想配列で返すことができる。
     *
     * 同様に、$key にクロージャを与えると、その返り値が true 相当のものを伏せて配列で返す。
     * callable ではなくクロージャのみ対応する。
     *
     * Example:
     * ```php
     * $array = ['a' => 'A', 'b' => 'B'];
     * // ない場合は $default を返す
     * that(array_unset($array, 'x', 'X'))->isSame('X');
     * // 指定したキーを返す。そのキーは伏せられている
     * that(array_unset($array, 'a'))->isSame('A');
     * that($array)->isSame(['b' => 'B']);
     *
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // 配列を与えるとそれらを返す。そのキーは全て伏せられている
     * that(array_unset($array, ['a', 'b', 'x']))->isSame(['A', 'B']);
     * that($array)->isSame(['c' => 'C']);
     *
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // 配列のキーは返されるキーを表す。順番も維持される
     * that(array_unset($array, ['x2' => 'b', 'x1' => 'a']))->isSame(['x2' => 'B', 'x1' => 'A']);
     *
     * $array = ['hoge' => 'HOGE', 'fuga' => 'FUGA', 'piyo' => 'PIYO'];
     * // 値に "G" を含むものを返す。その要素は伏せられている
     * that(array_unset($array, fn($v) => strpos($v, 'G') !== false))->isSame(['hoge' => 'HOGE', 'fuga' => 'FUGA']);
     * that($array)->isSame(['piyo' => 'PIYO']);
     * ```
     *
     * @param array $array 配列
     * @param string|int|array|callable $key 伏せたいキー。配列を与えると全て伏せる。クロージャの場合は true 相当を伏せる
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 指定したキーの値
     */
    function array_unset(&$array, $key, $default = null)
    {
        if (is_array($key)) {
            $result = [];
            foreach ($key as $rk => $ak) {
                if (array_keys_exist($ak, $array)) {
                    $result[$rk] = $array[$ak];
                    unset($array[$ak]);
                }
            }
            if (!$result) {
                // 明示的に与えられていないなら [] を使用する
                if (func_num_args() === 2) {
                    $default = [];
                }
                return $default;
            }
            return $result;
        }

        if ($key instanceof \Closure) {
            $result = [];
            $n = 0;
            foreach ($array as $k => $v) {
                if ($key($v, $k, $n++)) {
                    $result[$k] = $v;
                    unset($array[$k]);
                }
            }
            if (!$result) {
                return $default;
            }
            return $result;
        }

        if (array_keys_exist($key, $array)) {
            $result = $array[$key];
            unset($array[$key]);
            return $result;
        }
        return $default;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\array_unset") && !defined("ryunosuke\\PHPUnit\\array_unset")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\array_unset", "ryunosuke\\PHPUnit\\array_unset");
}

if (!isset($excluded_functions["array_keys_exist"]) && (!function_exists("ryunosuke\\PHPUnit\\array_keys_exist") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\array_keys_exist"))->isInternal()))) {
    /**
     * array_key_exists の複数版
     *
     * 指定キーが全て存在するなら true を返す。
     * 配列ではなく単一文字列を与えても動作する（array_key_exists と全く同じ動作になる）。
     *
     * $keys に空を与えると例外を投げる。
     * $keys に配列を与えるとキーで潜ってチェックする（Example 参照）。
     *
     * Example:
     * ```php
     * // すべて含むので true
     * that(array_keys_exist(['a', 'b', 'c'], ['a' => 'A', 'b' => 'B', 'c' => 'C']))->isTrue();
     * // N は含まないので false
     * that(array_keys_exist(['a', 'b', 'N'], ['a' => 'A', 'b' => 'B', 'c' => 'C']))->isFalse();
     * // 配列を与えると潜る（日本語で言えば「a というキーと、x というキーとその中に x1, x2 というキーがあるか？」）
     * that(array_keys_exist(['a', 'x' => ['x1', 'x2']], ['a' => 'A', 'x' => ['x1' => 'X1', 'x2' => 'X2']]))->isTrue();
     * ```
     *
     * @param array|string $keys 調べるキー
     * @param array|\ArrayAccess $array 調べる配列
     * @return bool 指定キーが全て存在するなら true
     */
    function array_keys_exist($keys, $array)
    {
        $keys = is_iterable($keys) ? $keys : [$keys];
        if (is_empty($keys)) {
            throw new \InvalidArgumentException('$keys is empty.');
        }

        $is_arrayaccess = $array instanceof \ArrayAccess;

        foreach ($keys as $k => $key) {
            if (is_array($key)) {
                // まずそのキーをチェックして
                if (!array_keys_exist($k, $array)) {
                    return false;
                }
                // あるなら再帰する
                if (!array_keys_exist($key, $array[$k])) {
                    return false;
                }
            }
            elseif ($is_arrayaccess) {
                if (!$array->offsetExists($key)) {
                    return false;
                }
            }
            elseif (!array_key_exists($key, $array)) {
                return false;
            }
        }
        return true;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\array_keys_exist") && !defined("ryunosuke\\PHPUnit\\array_keys_exist")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\array_keys_exist", "ryunosuke\\PHPUnit\\array_keys_exist");
}

if (!isset($excluded_functions["array_find"]) && (!function_exists("ryunosuke\\PHPUnit\\array_find") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\array_find"))->isInternal()))) {
    /**
     * array_search のクロージャ版のようなもの
     *
     * コールバックの返り値が true 相当のものを返す。
     * $is_key に true を与えるとそのキーを返す（デフォルトの動作）。
     * $is_key に false を与えるとコールバックの結果を返す。
     *
     * この関数は論理値 FALSE を返す可能性がありますが、FALSE として評価される値を返す可能性もあります。
     *
     * Example:
     * ```php
     * // 最初に見つかったキーを返す
     * that(array_find(['a', '8', '9'], 'ctype_digit'))->isSame(1);
     * that(array_find(['a', 'b', 'b'], fn($v) => $v === 'b'))->isSame(1);
     * // 最初に見つかったコールバック結果を返す（最初の数字の2乗を返す）
     * $ifnumeric2power = fn($v) => ctype_digit($v) ? $v * $v : false;
     * that(array_find(['a', '8', '9'], $ifnumeric2power, false))->isSame(64);
     * ```
     *
     * @param iterable $array 調べる配列
     * @param callable $callback 評価コールバック
     * @param bool $is_key キーを返すか否か
     * @return mixed コールバックが true を返した最初のキー。存在しなかったら false
     */
    function array_find($array, $callback, $is_key = true)
    {
        $callback = func_user_func_array($callback);

        $n = 0;
        foreach ($array as $k => $v) {
            $result = $callback($v, $k, $n++);
            if ($result) {
                if ($is_key) {
                    return $k;
                }
                return $result;
            }
        }
        return false;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\array_find") && !defined("ryunosuke\\PHPUnit\\array_find")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\array_find", "ryunosuke\\PHPUnit\\array_find");
}

if (!isset($excluded_functions["array_insert"]) && (!function_exists("ryunosuke\\PHPUnit\\array_insert") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\array_insert"))->isInternal()))) {
    /**
     * 配列・連想配列を問わず任意の位置に値を挿入する
     *
     * $position を省略すると最後に挿入される（≒ array_push）。
     * $position に負数を与えると後ろから数えられる。
     * $value には配列も与えられるが、その場合数値キーは振り直される
     *
     * Example:
     * ```php
     * that(array_insert([1, 2, 3], 'x'))->isSame([1, 2, 3, 'x']);
     * that(array_insert([1, 2, 3], 'x', 1))->isSame([1, 'x', 2, 3]);
     * that(array_insert([1, 2, 3], 'x', -1))->isSame([1, 2, 'x', 3]);
     * that(array_insert([1, 2, 3], ['a' => 'A', 'b' => 'B'], 1))->isSame([1, 'a' => 'A', 'b' => 'B', 2, 3]);
     * ```
     *
     * @param array $array 対象配列
     * @param mixed $value 挿入値
     * @param int|null $position 挿入位置
     * @return array 挿入された新しい配列
     */
    function array_insert($array, $value, $position = null)
    {
        if (!is_array($value)) {
            $value = [$value];
        }

        $position = is_null($position) ? count($array) : intval($position);

        $sarray = array_splice($array, 0, $position);
        return array_merge($sarray, $value, $array);
    }
}
if (function_exists("ryunosuke\\PHPUnit\\array_insert") && !defined("ryunosuke\\PHPUnit\\array_insert")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\array_insert", "ryunosuke\\PHPUnit\\array_insert");
}

if (!isset($excluded_functions["array_all"]) && (!function_exists("ryunosuke\\PHPUnit\\array_all") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\array_all"))->isInternal()))) {
    /**
     * 全要素が true になるなら true を返す（1つでも false なら false を返す）
     *
     * $callback が要求するならキーも渡ってくる。
     *
     * Example:
     * ```php
     * that(array_all([true, true]))->isTrue();
     * that(array_all([true, false]))->isFalse();
     * that(array_all([false, false]))->isFalse();
     * ```
     *
     * @param iterable $array 対象配列
     * @param ?callable $callback 評価クロージャ。 null なら値そのもので評価
     * @param bool|mixed $default 空配列の場合のデフォルト値
     * @return bool 全要素が true なら true
     */
    function array_all($array, $callback = null, $default = true)
    {
        if (is_empty($array)) {
            return $default;
        }

        $callback = func_user_func_array($callback);

        $n = 0;
        foreach ($array as $k => $v) {
            if (!$callback($v, $k, $n++)) {
                return false;
            }
        }
        return true;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\array_all") && !defined("ryunosuke\\PHPUnit\\array_all")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\array_all", "ryunosuke\\PHPUnit\\array_all");
}

if (!isset($excluded_functions["array_flatten"]) && (!function_exists("ryunosuke\\PHPUnit\\array_flatten") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\array_flatten"))->isInternal()))) {
    /**
     * 多階層配列をフラットに展開する
     *
     * 巷にあふれている実装と違って、 ["$pkey.$ckey" => $value] 形式の配列でも返せる。
     * $delimiter で区切り文字を指定した場合にそのようになる。
     * $delimiter = null の場合に本当の配列で返す（巷の実装と同じ）。
     *
     * Example:
     * ```php
     * $array = [
     *    'k1' => 'v1',
     *    'k2' => [
     *        'k21' => 'v21',
     *        'k22' => [
     *            'k221' => 'v221',
     *            'k222' => 'v222',
     *            'k223' => [1, 2, 3],
     *        ],
     *    ],
     * ];
     * // 区切り文字指定なし
     * that(array_flatten($array))->isSame([
     *    0 => 'v1',
     *    1 => 'v21',
     *    2 => 'v221',
     *    3 => 'v222',
     *    4 => 1,
     *    5 => 2,
     *    6 => 3,
     * ]);
     * // 区切り文字指定
     * that(array_flatten($array, '.'))->isSame([
     *    'k1'            => 'v1',
     *    'k2.k21'        => 'v21',
     *    'k2.k22.k221'   => 'v221',
     *    'k2.k22.k222'   => 'v222',
     *    'k2.k22.k223.0' => 1,
     *    'k2.k22.k223.1' => 2,
     *    'k2.k22.k223.2' => 3,
     * ]);
     * ```
     *
     * @param iterable $array 対象配列
     * @param string|\Closure|null $delimiter キーの区切り文字。 null を与えると連番になる
     * @return array フラット化された配列
     */
    function array_flatten($array, $delimiter = null)
    {
        $result = [];
        $core = function ($array, $delimiter, $parents) use (&$core, &$result) {
            foreach ($array as $k => $v) {
                $keys = $parents;
                $keys[] = $k;
                if (is_iterable($v)) {
                    $core($v, $delimiter, $keys);
                }
                else {
                    if ($delimiter === null) {
                        $result[] = $v;
                    }
                    elseif ($delimiter instanceof \Closure) {
                        $result[$delimiter($keys)] = $v;
                    }
                    else {
                        $result[implode($delimiter, $keys)] = $v;
                    }
                }
            }
        };

        $core($array, $delimiter, []);
        return $result;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\array_flatten") && !defined("ryunosuke\\PHPUnit\\array_flatten")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\array_flatten", "ryunosuke\\PHPUnit\\array_flatten");
}

if (!isset($excluded_functions["auto_loader"]) && (!function_exists("ryunosuke\\PHPUnit\\auto_loader") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\auto_loader"))->isInternal()))) {
    /**
     * vendor/autoload.php を返す
     *
     * かなり局所的な実装で vendor ディレクトリを変更していたりするとそれだけで例外になる。
     *
     * Example:
     * ```php
     * that(auto_loader())->contains('autoload.php');
     * ```
     *
     * @param ?string $startdir 高速化用の検索開始ディレクトリを指定するが、どちらかと言えばテスト用
     * @return string autoload.php のフルパス
     */
    function auto_loader($startdir = null)
    {
        return cache("path-$startdir", function () use ($startdir) {
            $cache = dirname_r($startdir ?: __DIR__, function ($dir) {
                if (file_exists($file = "$dir/autoload.php") || file_exists($file = "$dir/vendor/autoload.php")) {
                    return $file;
                }
            });
            if (!$cache) {
                throw new \DomainException('autoloader is not found.');
            }
            return $cache;
        }, __FUNCTION__);
    }
}
if (function_exists("ryunosuke\\PHPUnit\\auto_loader") && !defined("ryunosuke\\PHPUnit\\auto_loader")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\auto_loader", "ryunosuke\\PHPUnit\\auto_loader");
}

if (!isset($excluded_functions["reflect_types"]) && (!function_exists("ryunosuke\\PHPUnit\\reflect_types") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\reflect_types"))->isInternal()))) {
    /**
     * ReflectionType の型配列を返す
     *
     * ReflectionType のインターフェース・仕様がコロコロ変わってついていけないので関数化した。
     *
     * ReflectionType に準ずるインスタンスを渡すと取り得る候補を配列ライクなオブジェクトで返す。
     * 引数は配列で複数与えても良い。よしなに扱って複数型として返す。
     * また「Type が一意に導出できる Reflection」を渡しても良い（ReflectionProperty など）。
     * null を与えた場合はエラーにはならず、スルーされる（getType は null を返し得るので利便性のため）。
     *
     * 単純に ReflectionType の配列ライクなオブジェクトを返すが、そのオブジェクトは `__toString` が実装されており、文字列化するとパイプ区切りの型文字列を返す。
     * これは 8.0 における ReflectionUnionType の `__toString` を模倣したものである。
     * 互換性のある型があった場合、上位の型に内包されて型文字列としては出現しない。
     *
     * Countable も実装されているが、その結果は「内部 Type の数」ではなく、論理的に「取り得る型の数」を返す。
     * 例えば `?int` は型としては1つだが、実際は int, null の2つを取り得るため、 count は 2 を返す。
     * 端的に言えば「`__toString` のパイプ区切りの型の数」を返す。
     *
     * あとは便利メソッドとして下記が生えている。
     *
     * - jsonSerialize: JsonSerializable 実装
     * - getTypes: 取り得る型をすべて返す（ReflectionUnionType 互換）
     * - getName: ReflectionUnionType 非互換 toString な型宣言文字列を返す
     * - allows: その値を取りうるか判定して返す
     *
     * ReflectionUnionType とは完全互換ではないので、php8.0が完全に使える環境であれば素直に ReflectionUnionType を使ったほうが良い。
     * （「常に（型分岐せずに）複数形で扱える」程度のメリットしかない。allows は惜しいが）。
     *
     * ちなみに型の変遷は下記の通り。
     *
     * - php7.1: ReflectionType::__toString が非推奨になった
     * - php7.1: ReflectionNamedType が追加され、各種 getType でそれを返すようになった
     * - php8.0: ReflectionType::__toString が非推奨ではなくなった
     * - php8.0: ReflectionUnionType が追加され、複合の場合は getType でそれを返すようになった
     *
     * Example:
     * ```php
     * $object = new class {
     *     function method(object $o):?string {}
     * };
     * $method = new \ReflectionMethod($object, 'method');
     * $types = reflect_types($method->getParameters()[0]->getType());
     * // 文字列化すると型宣言文字列を返すし、配列アクセスや count, iterable でそれぞれの型が得られる
     * that((string) $types)->is('object');
     * that($types[0])->isInstanceOf(\ReflectionType::class);
     * that(iterator_to_array($types))->eachIsInstanceOf(\ReflectionType::class);
     * that(count($types))->is(1);
     * // 返り値でも同じ（null 許容なので null が付くし count も 2 になる）
     * $types = reflect_types($method->getReturnType());
     * that((string) $types)->is('string|null');
     * that(count($types))->is(2);
     * ```
     *
     * @param \ReflectionFunctionAbstract|\ReflectionType|\ReflectionType[]|null $reflection_type getType 等で得られるインスタンス
     * @return \ReflectionAnyType|object
     */
    function reflect_types($reflection_type = null)
    {
        if (!is_array($reflection_type)) {
            $reflection_type = [$reflection_type];
        }

        foreach ($reflection_type as $n => $rtype) {
            if ($rtype instanceof \ReflectionProperty) {
                $reflection_type[$n] = $rtype->getType();
            }
            if ($rtype instanceof \ReflectionFunctionAbstract) {
                $reflection_type[$n] = $rtype->getReturnType();
            }
            if ($rtype instanceof \ReflectionParameter) {
                $reflection_type[$n] = $rtype->getType();
            }
        }

        return new class(...$reflection_type)
            extends \stdClass
            implements \IteratorAggregate, \ArrayAccess, \Countable, \JsonSerializable {

            private const PSEUDO = [
                'mixed'    => [],
                'static'   => ['object', 'mixed'],
                'self'     => ['static', 'object', 'mixed'],
                'parent'   => ['static', 'object', 'mixed'],
                'callable' => ['mixed'],
                'iterable' => ['mixed'],
                'object'   => ['mixed'],
                'array'    => ['iterable', 'mixed'],
                'string'   => ['mixed'],
                'int'      => ['mixed'],
                'float'    => ['mixed'],
                'bool'     => ['mixed'],
                'false'    => ['bool', 'mixed'],
                'null'     => ['mixed'],
                'void'     => [],
            ];

            public function __construct(?\ReflectionType ...$reflection_types)
            {
                $types = [];
                foreach ($reflection_types as $type) {
                    if ($type === null) {
                        continue;
                    }

                    /** @noinspection PhpElementIsNotAvailableInCurrentPhpVersionInspection */
                    $types = array_merge($types, $type instanceof \ReflectionUnionType ? $type->getTypes() : [$type]);
                }

                // 配列キャストで配列を得たいので下手にフィールドを宣言せず直に生やす
                foreach ($types as $n => $type) {
                    $this->$n = $type;
                }
            }

            public function __toString()
            {
                return implode('|', $this->toStrings(true, true));
            }

            public function getIterator(): \Traversable
            {
                // yield from $this->getTypes();
                return new \ArrayIterator($this->getTypes());
            }

            public function offsetExists($offset): bool
            {
                return isset($this->$offset);
            }

            /** @noinspection PhpLanguageLevelInspection */
            #[\ReturnTypeWillChange]
            public function offsetGet($offset)
            {
                return $this->$offset;
            }

            public function offsetSet($offset, $value): void
            {
                // for debug
                if (is_string($value)) {
                    $value = new class ($value, self::PSEUDO) extends \ReflectionNamedType {
                        private $typename;
                        private $nullable;
                        private $builtins;

                        public function __construct($typename, $builtins)
                        {
                            $this->typename = ltrim($typename, '?');
                            $this->nullable = $typename[0] === '?';
                            $this->builtins = $builtins;
                        }

                        public function getName(): string { return $this->typename; }

                        public function allowsNull(): bool { return $this->nullable; }

                        public function isBuiltin(): bool { return isset($this->builtins[$this->typename]); }

                        public function __toString(): string { return $this->getName(); }
                    };
                }

                assert($value instanceof \ReflectionType);
                if ($offset === null) {
                    $offset = max(array_keys($this->getTypes()) ?: [-1]) + 1;
                }
                $this->$offset = $value;
            }

            public function offsetUnset($offset): void
            {
                unset($this->$offset);
            }

            public function count(): int
            {
                return count($this->toStrings(true, false));
            }

            public function jsonSerialize(): array
            {
                return $this->toStrings(true, true);
            }

            public function getName()
            {
                $types = array_flip($this->toStrings(true, true));
                $nullable = false;
                if (isset($types['null']) && count($types) === 2) {
                    unset($types['null']);
                    $nullable = true;
                }

                $result = [];
                foreach ($types as $type => $dummy) {
                    $result[] = (isset(self::PSEUDO[$type]) ? '' : '\\') . $type;
                }
                return ($nullable ? '?' : '') . implode('|', $result);
            }

            public function getTypes()
            {
                return (array) $this;
            }

            public function allows($type, $strict = false)
            {
                $types = array_flip($this->toStrings(false, false));

                if (isset($types['mixed'])) {
                    return true;
                }

                foreach ($types as $allow => $dummy) {
                    if (function_exists($f = "is_$allow") && $f($type)) {
                        return true;
                    }
                    if (is_a($type, $allow, true)) {
                        return true;
                    }
                }

                if (!$strict) {
                    if (is_int($type) || is_float($type) || is_bool($type)) {
                        if (isset($types['int']) || isset($types['float']) || isset($types['bool']) || isset($types['string'])) {
                            return true;
                        }
                    }
                    if (is_string($type) || (is_object($type) && method_exists($type, '__toString'))) {
                        if (isset($types['string'])) {
                            return true;
                        }
                        if ((isset($types['int']) || isset($types['float'])) && is_numeric("$type")) {
                            return true;
                        }
                    }
                }
                return false;
            }

            private function toStrings($ignore_compatible = true, $sort = true)
            {
                $types = [];
                foreach ($this->getTypes() as $type) {
                    // ドキュメント上は「ReflectionNamedType を返す可能性があります」とのことなので getName 前提はダメ
                    // かといって文字列化前提だと 7.1 以降で deprecated が出てしまう
                    // つまり愚直に分岐するか @ で抑制するくらいしか多バージョン対応する術がない（7.1 の deprecated を解除して欲しい…）
                    $types[$type instanceof \ReflectionNamedType ? $type->getName() : (string) $type] = true;

                    if ($type->allowsNull()) {
                        $types['null'] = true;
                    }
                }

                if ($ignore_compatible) {
                    $types = array_filter($types, function ($type) use ($types) {
                        // いくつか互換のある内包疑似型が存在する（iterable は array を内包するし、 bool は false を内包する）
                        foreach (self::PSEUDO[$type] ?? [] as $parent) {
                            if (isset($types[$parent])) {
                                return false;
                            }
                        }
                        // さらに object 疑似型は全てのクラス名を内包する
                        if (isset($types['object']) && !isset(self::PSEUDO[$type])) {
                            return false;
                        }
                        return true;
                    }, ARRAY_FILTER_USE_KEY);
                }

                if ($sort) {
                    static $orders = null;
                    $orders ??= array_flip(array_keys(self::PSEUDO));
                    uksort($types, function ($a, $b) use ($orders) {
                        $issetA = isset($orders[$a]);
                        $issetB = isset($orders[$b]);
                        switch (true) {
                            case $issetA && $issetB:   // 共に疑似型
                                return $orders[$a] - $orders[$b];
                            case !$issetA && !$issetB: // 共にクラス名
                                return strcasecmp($a, $b);
                            case !$issetA && $issetB:  // A だけがクラス名
                                return -1;
                            case $issetA && !$issetB:  // B だけがクラス名
                                return +1;
                        }
                    });
                }
                return array_keys($types);
            }
        };
    }
}
if (function_exists("ryunosuke\\PHPUnit\\reflect_types") && !defined("ryunosuke\\PHPUnit\\reflect_types")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\reflect_types", "ryunosuke\\PHPUnit\\reflect_types");
}

if (!isset($excluded_functions["get_object_properties"]) && (!function_exists("ryunosuke\\PHPUnit\\get_object_properties") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\get_object_properties"))->isInternal()))) {
    /**
     * オブジェクトのプロパティを可視・不可視を問わず取得する
     *
     * get_object_vars + no public プロパティを返すイメージ。
     * クロージャだけは特別扱いで this + use 変数を返す。
     *
     * Example:
     * ```php
     * $object = new \Exception('something', 42);
     * $object->oreore = 'oreore';
     *
     * // get_object_vars はそのスコープから見えないプロパティを取得できない
     * // var_dump(get_object_vars($object));
     *
     * // array キャストは全て得られるが null 文字を含むので扱いにくい
     * // var_dump((array) $object);
     *
     * // この関数を使えば不可視プロパティも取得できる
     * that(get_object_properties($object))->subsetEquals([
     *     'message' => 'something',
     *     'code'    => 42,
     *     'oreore'  => 'oreore',
     * ]);
     *
     * // クロージャは this と use 変数を返す
     * that(get_object_properties(fn() => $object))->is([
     *     'this'   => $this,
     *     'object' => $object,
     * ]);
     * ```
     *
     * @param object $object オブジェクト
     * @param array $privates 継承ツリー上の private が格納される
     * @return array 全プロパティの配列
     */
    function get_object_properties($object, &$privates = [])
    {
        if ($object instanceof \Closure) {
            $ref = new \ReflectionFunction($object);
            $uses = method_exists($ref, 'getClosureUsedVariables') ? $ref->getClosureUsedVariables() : $ref->getStaticVariables();
            return ['this' => $ref->getClosureThis()] + $uses;
        }

        $fields = [];
        foreach ((array) $object as $name => $field) {
            $cname = '';
            $names = explode("\0", $name);
            if (count($names) > 1) {
                $name = array_pop($names);
                $cname = $names[1];
            }
            $fields[$cname][$name] = $field;
        }

        $classname = get_class($object);
        $parents = array_values(['', '*', $classname] + class_parents($object));
        uksort($fields, function ($a, $b) use ($parents) {
            return array_search($a, $parents, true) <=> array_search($b, $parents, true);
        });

        $result = [];
        foreach ($fields as $cname => $props) {
            foreach ($props as $name => $field) {
                if ($cname !== '' && $cname !== '*' && $classname !== $cname) {
                    $privates[$cname][$name] = $field;
                }
                if (!array_key_exists($name, $result)) {
                    $result[$name] = $field;
                }
            }
        }

        return $result;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\get_object_properties") && !defined("ryunosuke\\PHPUnit\\get_object_properties")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\get_object_properties", "ryunosuke\\PHPUnit\\get_object_properties");
}

if (!isset($excluded_functions["date_timestamp"]) && (!function_exists("ryunosuke\\PHPUnit\\date_timestamp") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\date_timestamp"))->isInternal()))) {
    /**
     * 日時的なものをよしなにタイムスタンプに変換する
     *
     * マイクロ秒にも対応している。つまり返り値は int か float になる。
     * また、相対指定の +1 month の月末問題は起きないようにしてある。
     *
     * かなり適当に和暦にも対応している。
     * さらに必要に迫られてかなり特殊な対応を行っているので Example を参照。
     *
     * Example:
     * ```php
     * // 普通の日時文字列
     * that(date_timestamp('2014/12/24 12:34:56'))->isSame(strtotime('2014/12/24 12:34:56'));
     * // 和暦
     * that(date_timestamp('昭和31年12月24日 12時34分56秒'))->isSame(strtotime('1956/12/24 12:34:56'));
     * // 相対指定
     * that(date_timestamp('2012/01/31 +1 month'))->isSame(strtotime('2012/02/29'));
     * that(date_timestamp('2012/03/31 -1 month'))->isSame(strtotime('2012/02/29'));
     * // マイクロ秒
     * that(date_timestamp('2014/12/24 12:34:56.789'))->isSame(1419392096.789);
     *
     * // ベース日時
     * $baseTimestamp = strtotime('2012/01/31');
     * // ベース日時の25日（strtotime の序数日付は first/last しか対応していないが、この関数は対応している）
     * that(date_timestamp('25th of this month', $baseTimestamp))->isSame(strtotime('2012/01/25'));
     * // ベース日時の第2月曜（strtotime の序数曜日は 1st のような表記に対応していないが、この関数は対応している）
     * that(date_timestamp('2nd monday of this month', $baseTimestamp))->isSame(strtotime('2012/01/09'));
     * ```
     *
     * @param string|int|float|\DateTimeInterface $datetimedata 日時データ
     * @param int|null $baseTimestamp 日時データ
     * @return int|float|null タイムスタンプ。パース失敗時は null
     */
    function date_timestamp($datetimedata, $baseTimestamp = null)
    {
        if ($datetimedata instanceof \DateTimeInterface) {
            return $datetimedata->getTimestamp() + $datetimedata->format('u') / 1000 / 1000;
        }

        $DAY1 = 60 * 60 * 24;
        $ORDINAL_WORDS = [
            '1st'  => 'first',
            '2nd'  => 'second',
            '3rd'  => 'third',
            '4th'  => 'fourth',
            '5th'  => 'fifth',
            '6th'  => 'sixth',
            '7th'  => 'seventh',
            '8th'  => 'eighth',
            '9th'  => 'ninth',
            '10th' => 'tenth',
            '11th' => 'eleventh',
            '12th' => 'twelfth',
        ];

        $ordinal_day = null;
        $oddeven = null;
        if (is_string($datetimedata) || (is_object($datetimedata) && method_exists($datetimedata, '__toString'))) {
            // 全角を含めた trim
            $chars = "[\\x0-\x20\x7f\xc2\xa0\xe3\x80\x80]";
            $datetimedata = preg_replace("/\A{$chars}++|{$chars}++\z/u", '', $datetimedata);

            // 和暦を西暦に置換
            $jpnames = array_merge(array_column(JP_ERA, 'name'), array_column(JP_ERA, 'abbr'));
            $datetimedata = preg_replace_callback('/^(' . implode('|', $jpnames) . ')(\d{1,2}|元)/u', function ($matches) {
                [, $era, $year] = $matches;
                $eratime = array_find(JP_ERA, function ($v) use ($era) {
                    if (in_array($era, [$v['name'], $v['abbr']], true)) {
                        return $v['since'];
                    }
                }, false);
                return idate('Y', $eratime) + ($year === '元' ? 1 : $year) - 1;
            }, $datetimedata);

            // 単位文字列を置換
            $datetimedata = strtr($datetimedata, [
                '　'    => ' ',
                '西暦' => '',
                '年'   => '/',
                '月'   => '/',
                '日'   => ' ',
                '時'   => ':',
                '分'   => ':',
                '秒'   => '',
            ]);
            $datetimedata = trim($datetimedata, " \t\n\r\0\x0B:/");

            // 1st, 2nd, 3rd, 4th dayname の対応
            $datetimedata = preg_replace_callback('#((\d{1,2})(st|nd|rd|th))(\s+(sun|mon|tues?|wed(nes)?|thu(rs)?|fri|sat(ur)?)day)#u', function ($matches) use ($ORDINAL_WORDS) {
                if (!isset($ORDINAL_WORDS[$matches[1]])) {
                    return $matches[0];
                }

                return $ORDINAL_WORDS[$matches[1]] . $matches[4];
            }, $datetimedata);

            // 1st, 2nd, 3rd, 4th day の対応
            $datetimedata = preg_replace_callback('#((\d{1,2})(st|nd|rd|th))(\s+day)?#ui', function ($matches) use (&$ordinal_day) {
                if ($matches[1] !== (new \NumberFormatter('en', \NumberFormatter::ORDINAL))->format($matches[2])) {
                    return $matches[0];
                }

                $ordinal_day = $matches[2];
                return 'first day';
            }, $datetimedata);

            // odd, even の対応
            $datetimedata = preg_replace_callback('#(odd|even)\s+#ui', function ($matches) use (&$oddeven) {
                $oddeven = $matches[1];
                return 'this ';
            }, $datetimedata);
        }

        // 数値4桁は年と解釈されるように
        if (preg_match('/^[0-9]{4}$/', $datetimedata)) {
            $datetimedata .= '-01-01';
        }

        // 数値系はタイムスタンプとみなす
        if (ctype_digit("$datetimedata")) {
            return (int) $datetimedata;
        }
        if (is_numeric($datetimedata)) {
            return (float) $datetimedata;
        }

        // strtotime と date_parse の合せ技で変換
        $baseTimestamp ??= time();
        $timestamp = strtotime($datetimedata, $baseTimestamp);
        $parts = date_parse($datetimedata);
        if ($timestamp === false || $parts['error_count']) {
            return null;
        }

        if (!checkdate($parts['month'], $parts['day'], $parts['year'])) {
            if (!isset($parts['relative'])) {
                return null;
            }
            $parts['year'] = idate('Y', $baseTimestamp);
            $parts['month'] = idate('m', $baseTimestamp);
            $parts['day'] = idate('d', $baseTimestamp);
        }

        if ($ordinal_day) {
            $timestamp += ($ordinal_day - 1) * $DAY1;
        }

        if ($oddeven !== null) {
            $idateW2 = idate('W', $timestamp) % 2;
            if (($oddeven === 'odd' && $idateW2 === 0) || ($oddeven === 'even' && $idateW2 === 1)) {
                $timestamp += $DAY1 * 7;
            }
        }

        $relative = $parts['relative'] ?? [];
        if (($relative['month'] ?? false)
            && !isset($relative['weekday'])            // 週指定があるとかなり特殊で初日末日が意味を為さない
            && !isset($relative['first_day_of_month']) // first day 指定があるなら初日確定
            && !isset($relative['last_day_of_month'])  // last day 指定があるなら末日確定
        ) {
            $parts['month'] += $relative['month'];
            $parts['year'] += intdiv($parts['month'], 12);
            $parts['month'] %= 12;
            $parts['month'] += $parts['month'] <= 0 ? 12 : 0;

            if (!checkdate($parts['month'], $parts['day'], $parts['year'])) {
                $timestamp = strtotime(date('Y-m-t H:i:s', $timestamp - $DAY1 * 4));
            }
        }

        if ($parts['fraction']) {
            $timestamp += ($timestamp >= 0 ? +$parts['fraction'] : -$parts['fraction']);
        }
        return $timestamp;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\date_timestamp") && !defined("ryunosuke\\PHPUnit\\date_timestamp")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\date_timestamp", "ryunosuke\\PHPUnit\\date_timestamp");
}

if (!isset($excluded_functions["date_convert"]) && (!function_exists("ryunosuke\\PHPUnit\\date_convert") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\date_convert"))->isInternal()))) {
    /**
     * 日時文字列をよしなに別のフォーマットに変換する
     *
     * マイクロ秒にも対応している。
     * かなり適当に和暦にも対応している。
     *
     * Example:
     * ```php
     * // 和暦を Y/m/d H:i:s に変換
     * that(date_convert('Y/m/d H:i:s', '昭和31年12月24日 12時34分56秒'))->isSame('1956/12/24 12:34:56');
     * // 単純に「マイクロ秒が使える date」としても使える
     * $now = 1234567890.123; // テストがしづらいので固定時刻にする
     * that(date_convert('Y/m/d H:i:s.u', $now))->isSame('2009/02/14 08:31:30.122999');
     * // $format に DateTimeInterface 実装クラス名を与えるとそのインスタンスを返す
     * that(date_convert(\DateTimeImmutable::class, $now))->isInstanceOf(\DateTimeImmutable::class);
     * // null は DateTime を意味する
     * that(date_convert(null, $now))->isInstanceOf(\DateTime::class);
     * ```
     *
     * @todo 引数を入れ替えたほうが自然な気がする
     *
     * @param ?string $format フォーマット
     * @param string|int|float|\DateTimeInterface|null $datetimedata 日時データ。省略時は microtime
     * @return string|\DateTimeInterface 日時文字列。$format が null の場合は DateTime
     */
    function date_convert($format, $datetimedata = null)
    {
        $format ??= \DateTime::class;
        $return_object = class_exists($format) && is_subclass_of($format, \DateTimeInterface::class);

        if ($return_object && $datetimedata instanceof \DateTimeInterface) {
            return $datetimedata;
        }

        // 省略時は microtime
        if ($datetimedata === null) {
            $timestamp = microtime(true);
        }
        else {
            $timestamp = date_timestamp($datetimedata);
            if ($timestamp === null) {
                throw new \InvalidArgumentException("parse failed '$datetimedata'");
            }
        }

        if (!$return_object) {
            $era = array_find(JP_ERA, function ($era) use ($timestamp) {
                if ($era['since'] <= $timestamp) {
                    $era['year'] = idate('Y', (int) $timestamp) - idate('Y', $era['since']) + 1;
                    $era['gann'] = $era['year'] === 1 ? '元' : $era['year'];
                    return $era;
                }
            }, false);
            $format = strtr_escaped($format, [
                'J' => fn() => $era ? $era['name'] : throws(new \InvalidArgumentException("notfound JP_ERA '$datetimedata'")),
                'b' => fn() => $era ? $era['abbr'] : throws(new \InvalidArgumentException("notfound JP_ERA '$datetimedata'")),
                'k' => fn() => $era ? $era['year'] : throws(new \InvalidArgumentException("notfound JP_ERA '$datetimedata'")),
                'K' => fn() => $era ? $era['gann'] : throws(new \InvalidArgumentException("notfound JP_ERA '$datetimedata'")),
                'x' => fn() => ['日', '月', '火', '水', '木', '金', '土'][idate('w', (int) $timestamp)],
            ], '\\');
        }

        if (is_int($timestamp) && !$return_object) {
            return date($format, $timestamp);
        }

        $class = $return_object ? $format : \DateTime::class;
        $dt = new $class();
        $dt = $dt->setTimestamp((int) $timestamp);

        if (is_float($timestamp)) {
            $diff = (int) (($timestamp - (int) $timestamp) * 1000 * 1000);
            $dt = $dt->modify("$diff microsecond");
        }

        if ($return_object) {
            return $dt;
        }
        return $dt->format($format);
    }
}
if (function_exists("ryunosuke\\PHPUnit\\date_convert") && !defined("ryunosuke\\PHPUnit\\date_convert")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\date_convert", "ryunosuke\\PHPUnit\\date_convert");
}

if (!isset($excluded_functions["date_fromto"]) && (!function_exists("ryunosuke\\PHPUnit\\date_fromto") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\date_fromto"))->isInternal()))) {
    /**
     * 日時っぽい文字列とフォーマットを与えると取りうる範囲を返す
     *
     * 与えられた日時の最大の切り捨て日時と最小の切り上げ日時の配列を返す。
     * 日付文字列はある程度よしなに補完される（例えば "2014/12" は"2014年12月01日" と解釈されるし "12/24" は "今年12月24日" と解釈される）。
     *
     * Example:
     * ```php
     * that(date_fromto('Y/m/d H:i:s', '2010/11'))->isSame(["2010/11/01 00:00:00", "2010/12/01 00:00:00"]);
     * that(date_fromto('Y/m/d H:i:s', '2010/11/24'))->isSame(["2010/11/24 00:00:00", "2010/11/25 00:00:00"]);
     * that(date_fromto('Y/m/d H:i:s', '2010/11/24 13'))->isSame(["2010/11/24 13:00:00", "2010/11/24 14:00:00"]);
     * that(date_fromto('Y/m/d H:i:s', '2010/11/24 13:24'))->isSame(["2010/11/24 13:24:00", "2010/11/24 13:25:00"]);
     * ```
     *
     * @param string $format フォーマット。 null を与えるとタイムスタンプで返す
     * @param string $datetimestring 日時データ
     * @return array|null [from ～ to] な配列。解釈できない場合は null
     */
    function date_fromto($format, $datetimestring)
    {
        $parsed = date_parse($datetimestring);
        if (true
            && $parsed['year'] === false
            && $parsed['month'] === false
            && $parsed['day'] === false
            && $parsed['hour'] === false
            && $parsed['minute'] === false
            && $parsed['second'] === false) {
            return null;
        }

        [$date, $time] = preg_split('#[T\s　]#u', $datetimestring, -1, PREG_SPLIT_NO_EMPTY) + [0 => '', 1 => ''];
        [$y, $m, $d] = preg_split('#[^\d]+#u', $date, -1, PREG_SPLIT_NO_EMPTY) + [0 => null, 1 => null, 2 => null];
        [$h, $i, $s] = preg_split('#[^\d]+#u', $time, -1, PREG_SPLIT_NO_EMPTY) + [0 => null, 1 => null, 2 => null];

        // "2014/12" と "12/24" の区別はつかないので字数で判断
        if (strlen($y ?? '') <= 2) {
            [$y, $m, $d] = [null, $y, $m];
        }
        // 時刻区切りなし
        if (strlen($h ?? '') > 2) {
            [$h, $i, $s] = str_split($h, 2) + [0 => null, 1 => null, 2 => null];
        }

        // 文字列表現で妥当性を検証
        $strtime = sprintf('%04d-%02d-%02d %02d:%02d:%02d', $y ?? 1000, $m ?? 1, $d ?? 1, $h ?? 1, $i ?? 1, $s ?? 1);
        $datetime = date_create_from_format('Y-m-d H:i:s', $strtime);
        if (!$datetime || $datetime->format('Y-m-d H:i:s') !== $strtime) {
            return null;
        }

        $y ??= idate('Y');
        $ld = $d ?? idate('t', mktime(0, 0, 0, $m ?? 12, 1, $y));

        $min = mktime($h ?? 0, $i ?? 0, $s ?? 0, $m ?? 1, $d ?? 1, $y) + $parsed['fraction'];
        $max = mktime($h ?? 23, $i ?? 59, $s ?? 59, $m ?? 12, $d ?? $ld, $y) + 1;
        if ($format === null) {
            return [$min, $max];
        }
        return [date_convert($format, $min), date_convert($format, $max)];
    }
}
if (function_exists("ryunosuke\\PHPUnit\\date_fromto") && !defined("ryunosuke\\PHPUnit\\date_fromto")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\date_fromto", "ryunosuke\\PHPUnit\\date_fromto");
}

if (!isset($excluded_functions["file_matcher"]) && (!function_exists("ryunosuke\\PHPUnit\\file_matcher") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\file_matcher"))->isInternal()))) {
    /**
     * 各種属性を指定してファイルのマッチングを行うクロージャを返す
     *
     * ※ 内部向け
     *
     * @param array $filter_condition マッチャーコンディション配列（ソースを参照）
     * @return \Closure ファイルマッチャー
     */
    function file_matcher(array $filter_condition)
    {
        $filter_condition += [
            // common
            'dotfile'    => null,  // switch startWith "."
            'unixpath'   => true,  // convert "\\" -> "/"
            'casefold'   => false, // ignore case
            // by getType (string or [string])
            'type'       => null,
            '!type'      => null,
            // by getPerms (int)
            'perms'      => null,
            '!perms'     => null,
            // by getMTime (int or [int, int])
            'mtime'      => null,
            '!mtime'     => null,
            // by getSize (int or [int, int])
            'size'       => null,
            '!size'      => null,
            // by getPathname (glob or regex)
            'path'       => null,
            '!path'      => null,
            // by getPath or getSubpath (glob or regex)
            'dir'        => null,
            '!dir'       => null,
            // by getFilename (glob or regex)
            'name'       => null,
            '!name'      => null,
            // by getExtension (string or [string])
            'extension'  => null,
            '!extension' => null,
            // by contents (string)
            'contains'   => null,
            '!contains'  => null,
            // by custom condition (callable)
            'filter'     => null,
            '!filter'    => null,
        ];

        foreach ([
            'mtime'  => fn(...$args) => date_timestamp(...$args),
            '!mtime' => fn(...$args) => date_timestamp(...$args),
            'size'   => fn(...$args) => si_unprefix(...$args),
            '!size'  => fn(...$args) => si_unprefix(...$args),
        ] as $key => $map) {
            if (isset($filter_condition[$key])) {
                $range = $filter_condition[$key];
                if (!is_array($range)) {
                    $range = array_fill_keys([0, 1], $range);
                }
                $range = array_map($map, $range);
                $filter_condition[$key] = static function ($value) use ($range) {
                    return (!isset($range[0]) || $value >= $range[0]) && (!isset($range[1]) || $value <= $range[1]);
                };
            }
        }

        foreach ([
            'type'       => null,
            '!type'      => null,
            'extension'  => null,
            '!extension' => null,
        ] as $key => $map) {
            if (isset($filter_condition[$key])) {
                $array = array_flip((array) $filter_condition[$key]);
                if ($filter_condition['casefold']) {
                    $array = array_change_key_case($array, CASE_LOWER);
                }
                $filter_condition[$key] = static function ($value) use ($array) {
                    return isset($array[$value]);
                };
            }
        }

        foreach ([
            'path'  => null,
            '!path' => null,
            'dir'   => null,
            '!dir'  => null,
            'name'  => null,
            '!name' => null,
        ] as $key => $convert) {
            if (isset($filter_condition[$key])) {
                $pattern = $filter_condition[$key];
                preg_match('##', ''); // clear preg_last_error
                @preg_match($pattern, '');
                if (preg_last_error() === PREG_NO_ERROR) {
                    $filter_condition[$key] = static function ($string) use ($pattern, $filter_condition) {
                        $string = $filter_condition['unixpath'] && DIRECTORY_SEPARATOR === '\\' ? str_replace('\\', '/', $string) : $string;
                        return !!preg_match($pattern, $string);
                    };
                }
                else {
                    $filter_condition[$key] = static function ($string) use ($pattern, $filter_condition) {
                        $string = $filter_condition['unixpath'] && DIRECTORY_SEPARATOR === '\\' ? str_replace('\\', '/', $string) : $string;
                        $flags = 0;
                        $flags |= $filter_condition['casefold'] ? FNM_CASEFOLD : 0;
                        return fnmatch($pattern, $string, $flags);
                    };
                }
            }
        }

        return function ($file) use ($filter_condition) {
            if (!$file instanceof \SplFileInfo) {
                $file = new \SplFileInfo($file);
            }

            if (isset($filter_condition['dotfile']) && !$filter_condition['dotfile'] === (strpos($file->getFilename(), '.') === 0)) {
                return false;
            }

            foreach (['type' => false, '!type' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && (!file_exists($file->getPathname()) || $cond === $filter_condition[$key]($file->getType()))) {
                    return false;
                }
            }
            foreach (['perms' => false, '!perms' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && (!file_exists($file->getPathname()) || $cond === !!($filter_condition[$key] & $file->getPerms()))) {
                    return false;
                }
            }
            foreach (['mtime' => false, '!mtime' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && (!file_exists($file->getPathname()) || $cond === $filter_condition[$key]($file->getMTime()))) {
                    return false;
                }
            }
            foreach (['size' => false, '!size' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && (!file_exists($file->getPathname()) || $cond === $filter_condition[$key]($file->getSize()))) {
                    return false;
                }
            }
            foreach (['path' => false, '!path' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($file->getPathname())) {
                    return false;
                }
            }
            foreach (['dir' => false, '!dir' => true] as $key => $cond) {
                $dirname = $file instanceof \RecursiveDirectoryIterator ? $file->getSubPath() : $file->getPath();
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($dirname)) {
                    return false;
                }
            }
            foreach (['name' => false, '!name' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($file->getFilename())) {
                    return false;
                }
            }
            foreach (['extension' => false, '!extension' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($file->getExtension())) {
                    return false;
                }
            }
            foreach (['filter' => false, '!filter' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && $cond === !!$filter_condition[$key]($file)) {
                    return false;
                }
            }
            foreach (['contains' => false, '!contains' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && (!file_exists($file->getPathname()) || $cond === (file_pos($file->getPathname(), $filter_condition[$key]) !== false))) {
                    return false;
                }
            }

            return true;
        };
    }
}
if (function_exists("ryunosuke\\PHPUnit\\file_matcher") && !defined("ryunosuke\\PHPUnit\\file_matcher")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\file_matcher", "ryunosuke\\PHPUnit\\file_matcher");
}

if (!isset($excluded_functions["file_list"]) && (!function_exists("ryunosuke\\PHPUnit\\file_list") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\file_list"))->isInternal()))) {
    /**
     * ファイル一覧を配列で返す
     *
     * Example:
     * ```php
     * // 適当にファイルを用意
     * $DS = DIRECTORY_SEPARATOR;
     * $tmp = sys_get_temp_dir() . "{$DS}file_list";
     * rm_rf($tmp, false);
     * file_set_contents("$tmp/a.txt", 'a');
     * file_set_contents("$tmp/dir/b.txt", 'b');
     * file_set_contents("$tmp/dir/dir/c.txt", 'c');
     * // ファイル一覧が取得できる
     * that(file_list($tmp))->equalsCanonicalizing([
     *     "$tmp{$DS}a.txt",
     *     "$tmp{$DS}dir{$DS}b.txt",
     *     "$tmp{$DS}dir{$DS}dir{$DS}c.txt",
     * ]);
     * ```
     *
     * @param string $dirname 調べるディレクトリ名
     * @param array $filter_condition フィルタ条件
     * @return array|false ファイルの配列
     */
    function file_list($dirname, $filter_condition = [])
    {
        $dirname = path_normalize($dirname);
        if (!file_exists($dirname)) {
            return false;
        }

        $filter_condition += [
            'recursive' => true,
            'relative'  => false,
            '!type'     => 'dir',
        ];
        $match = file_matcher($filter_condition);

        $rdi = new \RecursiveDirectoryIterator($dirname, \FilesystemIterator::SKIP_DOTS | \FilesystemIterator::KEY_AS_PATHNAME | \FilesystemIterator::CURRENT_AS_SELF);

        if ($filter_condition['recursive']) {
            $iterator = new \RecursiveIteratorIterator($rdi, \RecursiveIteratorIterator::CHILD_FIRST);
        }
        else {
            $iterator = $rdi;
        }

        $result = [];
        foreach ($iterator as $fullpath => $it) {
            if (!$match($it)) {
                continue;
            }

            $result[] = $filter_condition['relative'] ? $it->getSubPathName() : $fullpath;
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\file_list") && !defined("ryunosuke\\PHPUnit\\file_list")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\file_list", "ryunosuke\\PHPUnit\\file_list");
}

if (!isset($excluded_functions["file_set_contents"]) && (!function_exists("ryunosuke\\PHPUnit\\file_set_contents") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\file_set_contents"))->isInternal()))) {
    /**
     * ディレクトリも掘る file_put_contents
     *
     * 書き込みは一時ファイルと rename を使用してアトミックに行われる。
     *
     * Example:
     * ```php
     * file_set_contents(sys_get_temp_dir() . '/not/filename.ext', 'hoge');
     * that(file_get_contents(sys_get_temp_dir() . '/not/filename.ext'))->isSame('hoge');
     * ```
     *
     * @param string $filename 書き込むファイル名
     * @param string $data 書き込む内容
     * @param int $umask ディレクトリを掘る際の umask
     * @return int 書き込まれたバイト数
     */
    function file_set_contents($filename, $data, $umask = 0002)
    {
        if (func_num_args() === 2) {
            $umask = umask();
        }

        $filename = path_normalize($filename);

        if (!is_dir($dirname = dirname($filename))) {
            if (!@mkdir_p($dirname, $umask)) {
                throw new \RuntimeException("failed to mkdir($dirname)");
            }
        }

        error_clear_last();
        $tempnam = @tempnam($dirname, 'tmp');
        if (strpos(error_get_last()['message'] ?? '', "file created in the system's temporary directory") !== false) {
            $result = file_put_contents($filename, $data);
            @chmod($filename, 0666 & ~$umask);
            return $result;
        }
        if (($result = file_put_contents($tempnam, $data)) !== false) {
            if (rename($tempnam, $filename)) {
                @chmod($filename, 0666 & ~$umask);
                return $result;
            }
            unlink($tempnam);
        }
        return false;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\file_set_contents") && !defined("ryunosuke\\PHPUnit\\file_set_contents")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\file_set_contents", "ryunosuke\\PHPUnit\\file_set_contents");
}

if (!isset($excluded_functions["file_pos"]) && (!function_exists("ryunosuke\\PHPUnit\\file_pos") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\file_pos"))->isInternal()))) {
    /**
     * 範囲指定でファイルを読んで位置を返す
     *
     * $needle に配列を与えると OR 的動作で一つでも見つかった時点の位置を返す。
     * このとき「どれが見つかったか？」は得られない（場合によっては不便なので将来の改修対象）。
     *
     * Example:
     * ```php
     * // 適当にファイルを用意
     * $testpath = sys_get_temp_dir() . '/file_pos.txt';
     * file_put_contents($testpath, "hoge\nfuga\npiyo\nfuga");
     * // fuga の位置を返す
     * that(file_pos($testpath, 'fuga'))->is(5);
     * // 2つ目の fuga の位置を返す
     * that(file_pos($testpath, 'fuga', 6))->is(15);
     * // 見つからない場合は false を返す
     * that(file_pos($testpath, 'hogera'))->is(false);
     * ```
     *
     * @param string $filename ファイル名
     * @param string|array $needle 探す文字列
     * @param int $start 読み込み位置
     * @param int|null $end 読み込むまでの位置。省略時は指定なし（最後まで）。負数は後ろからのインデックス
     * @param int|null $chunksize 読み込みチャンクサイズ。省略時は 4096 の倍数に正規化
     * @return int|false $needle の位置。見つからなかった場合は false
     */
    function file_pos($filename, $needle, $start = 0, $end = null, $chunksize = null)
    {
        if (!is_file($filename)) {
            throw new \InvalidArgumentException("'$filename' is not found.");
        }

        $needle = arrayval($needle, false);
        $maxlength = max(array_map('strlen', $needle));

        if ($start < 0) {
            $start += $filesize ?? $filesize = filesize($filename);
        }
        if ($end === null) {
            $end = $filesize ?? $filesize = filesize($filename);
        }
        if ($end < 0) {
            $end += $filesize ?? $filesize = filesize($filename);
        }
        if ($chunksize === null) {
            $chunksize = 4096 * ($maxlength % 4096 + 1);
        }

        assert(isset($filesize) || !isset($filesize));
        assert($chunksize >= $maxlength);

        $fp = fopen($filename, 'rb');
        try {
            fseek($fp, $start);
            while (!feof($fp)) {
                if ($start > $end) {
                    break;
                }
                $last = $part ?? '';
                $part = fread($fp, $chunksize);
                if (($p = strpos_array($part, $needle))) {
                    $min = min($p);
                    $result = $start + $min;
                    return $result + strlen($needle[array_flip($p)[$min]]) > $end ? false : $result;
                }
                if (($p = strpos_array($last . $part, $needle))) {
                    $min = min($p);
                    $result = $start + $min - strlen($last);
                    return $result + strlen($needle[array_flip($p)[$min]]) > $end ? false : $result;
                }
                $start += strlen($part);
            }
            return false;
        }
        finally {
            fclose($fp);
        }
    }
}
if (function_exists("ryunosuke\\PHPUnit\\file_pos") && !defined("ryunosuke\\PHPUnit\\file_pos")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\file_pos", "ryunosuke\\PHPUnit\\file_pos");
}

if (!isset($excluded_functions["mkdir_p"]) && (!function_exists("ryunosuke\\PHPUnit\\mkdir_p") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\mkdir_p"))->isInternal()))) {
    /**
     * ディレクトリを再帰的に掘る
     *
     * 既に存在する場合は何もしない（エラーも出さない）。
     *
     * @param string $dirname ディレクトリ名
     * @param int $umask ディレクトリを掘る際の umask
     * @return bool 作成したら true
     */
    function mkdir_p($dirname, $umask = 0002)
    {
        if (func_num_args() === 1) {
            $umask = umask();
        }

        if (file_exists($dirname)) {
            return false;
        }

        return mkdir($dirname, 0777 & (~$umask), true);
    }
}
if (function_exists("ryunosuke\\PHPUnit\\mkdir_p") && !defined("ryunosuke\\PHPUnit\\mkdir_p")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\mkdir_p", "ryunosuke\\PHPUnit\\mkdir_p");
}

if (!isset($excluded_functions["dirname_r"]) && (!function_exists("ryunosuke\\PHPUnit\\dirname_r") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\dirname_r"))->isInternal()))) {
    /**
     * コールバックが true 相当を返すまで親ディレクトリを辿り続ける
     *
     * コールバックには親ディレクトリが引数として渡ってくる。
     *
     * Example:
     * ```php
     * // //tmp/a/b/file.txt を作っておく
     * $tmp = sys_get_temp_dir();
     * file_set_contents("$tmp/a/b/file.txt", 'hoge');
     * // /a/b/c/d/e/f から開始して「どこかの階層の file.txt を探したい」という状況を想定
     * $callback = fn($path) => realpath("$path/file.txt");
     * that(dirname_r("$tmp/a/b/c/d/e/f", $callback))->isSame(realpath("$tmp/a/b/file.txt"));
     * ```
     *
     * @param string $path パス名
     * @param callable $callback コールバック
     * @return mixed $callback の返り値。頂上まで辿ったら false
     */
    function dirname_r($path, $callback)
    {
        $return = $callback($path);
        if ($return) {
            return $return;
        }

        $dirname = dirname($path);
        if ($dirname === $path) {
            return false;
        }
        return dirname_r($dirname, $callback);
    }
}
if (function_exists("ryunosuke\\PHPUnit\\dirname_r") && !defined("ryunosuke\\PHPUnit\\dirname_r")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\dirname_r", "ryunosuke\\PHPUnit\\dirname_r");
}

if (!isset($excluded_functions["fnmatch_or"]) && (!function_exists("ryunosuke\\PHPUnit\\fnmatch_or") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\fnmatch_or"))->isInternal()))) {
    /**
     * fnmatch の OR 版
     *
     * $patterns のうちどれか一つでもマッチしたら true を返す。
     * $patterns が空だと例外を投げる。
     *
     * Example:
     * ```php
     * // aaa にマッチするので true
     * that(fnmatch_or(['*aaa*', '*bbb*'], 'aaaX'))->isTrue();
     * // どれともマッチしないので false
     * that(fnmatch_or(['*aaa*', '*bbb*'], 'cccX'))->isFalse();
     * ```
     *
     * @param array|string $patterns パターン配列（単一文字列可）
     * @param string $string 調べる文字列
     * @param int $flags FNM_***
     * @return bool どれかにマッチしたら true
     */
    function fnmatch_or($patterns, $string, $flags = 0)
    {
        $patterns = is_iterable($patterns) ? $patterns : [$patterns];
        if (is_empty($patterns)) {
            throw new \InvalidArgumentException('$patterns must be not empty.');
        }

        foreach ($patterns as $pattern) {
            if (fnmatch($pattern, $string, $flags)) {
                return true;
            }
        }
        return false;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\fnmatch_or") && !defined("ryunosuke\\PHPUnit\\fnmatch_or")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\fnmatch_or", "ryunosuke\\PHPUnit\\fnmatch_or");
}

if (!isset($excluded_functions["path_normalize"]) && (!function_exists("ryunosuke\\PHPUnit\\path_normalize") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\path_normalize"))->isInternal()))) {
    /**
     * パスを正規化する
     *
     * 具体的には ./ や ../ を取り除いたり連続したディレクトリ区切りをまとめたりする。
     * realpath ではない。のでシンボリックリンクの解決などはしない。その代わりファイルが存在しなくても使用することができる。
     *
     * Example:
     * ```php
     * $DS = DIRECTORY_SEPARATOR;
     * that(path_normalize('/path/to/something'))->isSame("{$DS}path{$DS}to{$DS}something");
     * that(path_normalize('/path/through/../something'))->isSame("{$DS}path{$DS}something");
     * that(path_normalize('./path/current/./through/../something'))->isSame("path{$DS}current{$DS}something");
     * ```
     *
     * @param string $path パス文字列
     * @return string 正規化されたパス
     */
    function path_normalize($path)
    {
        $DS = DIRECTORY_SEPARATOR;

        // スキームの保護
        $with_scheme = false;
        $scheme = parse_url($path, PHP_URL_SCHEME);
        if (!($scheme === null || $scheme === 'file') && substr($path, strlen($scheme), 3) === '://') {
            $path = substr($path, strlen($scheme) + 3);
            $DS = '/';
            $with_scheme = true;
        }

        $delimiter = '/';
        if ($DS === '\\') {
            $delimiter .= '\\\\';
        }

        $result = [];
        foreach (preg_split("#[$delimiter]+#u", $path) as $part) {
            if ($part === '.') {
                continue;
            }
            if ($part === '..') {
                if (empty($result)) {
                    throw new \InvalidArgumentException("'$path' is invalid as path string.");
                }
                array_pop($result);
                continue;
            }
            $result[] = $part;
        }
        if (count($result) > 2 && $result[count($result) - 1] === '') {
            array_pop($result);
        }

        $path = implode($DS, $result);

        if ($with_scheme) {
            $path = "$scheme://$path";
        }

        return $path;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\path_normalize") && !defined("ryunosuke\\PHPUnit\\path_normalize")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\path_normalize", "ryunosuke\\PHPUnit\\path_normalize");
}

if (!isset($excluded_functions["memory_path"]) && (!function_exists("ryunosuke\\PHPUnit\\memory_path") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\memory_path"))->isInternal()))) {
    /**
     * ファイルのように扱えるメモリ上のパスを返す
     *
     * 劣化 vfsStream のようなもの。
     * stream wrapper を用いて実装しており、そのプロトコルは初回呼び出し時に1度だけ登録される。
     * プロトコル名は決め打ちだが、 php.ini に "rfunc.memory_stream" というキーで文字列を指定するとそれが使用される。
     *
     * Example:
     * ```php
     * // ファイル名のように読み書きができるパスを返す（一時ファイルを使用するよりかなり高速に動作する）
     * $memory_path = memory_path('filename.txt');
     * // 呼んだだけでは何もしないので存在しない
     * that(file_exists($memory_path))->isSame(false);
     * // file_put_contents が使える
     * that(file_put_contents($memory_path, 'Hello, World'))->isSame(12);
     * // file_get_contents が使える
     * that(file_get_contents($memory_path))->isSame('Hello, World');
     * // 上記の操作で実体が存在している
     * that(file_exists($memory_path))->isSame(true);
     * // unlink が使える
     * that(unlink($memory_path))->isSame(true);
     * // unlink したので存在しない
     * that(file_exists($memory_path))->isSame(false);
     * ```
     *
     * @param string $path パス名（実質的に一意なファイル名）
     * @return string メモリ上のパス
     */
    function memory_path($path = '')
    {
        static $STREAM_NAME, $registered = false;
        if (!$registered) {
            $STREAM_NAME = $STREAM_NAME ?: function_configure('memory_stream');
            if (in_array($STREAM_NAME, stream_get_wrappers())) {
                throw new \DomainException("$STREAM_NAME is registered already.");
            }

            $registered = true;
            stream_wrapper_register($STREAM_NAME, get_class(new class() {
                private static $entries = [];

                private $entry;
                private $id;
                private $position;
                private $appendable;

                public $context;

                private static function id($path)
                {
                    $parts = parse_url($path) ?: [];
                    $id = ($parts['host'] ?? '') . ($parts['path'] ?? '');
                    $id = strtr($id, ['\\' => '/']);
                    return rtrim($id, '/');
                }

                private static function create($id, $mode)
                {
                    // @todo time 系は一応用意しているだけでほとんど未実装（read/write のたびに更新する？）
                    $now = time();
                    self::$entries[$id] = (object) [
                        'mode'    => $mode | (0777 & ~umask()),
                        'owner'   => function_exists('posix_getuid') ? posix_getuid() : 0,
                        'group'   => function_exists('posix_getgid') ? posix_getgid() : 0,
                        'atime'   => $now,
                        'mtime'   => $now,
                        'ctime'   => $now,
                        'content' => '',
                    ];
                }

                private static function stat($id)
                {
                    $that = self::$entries[$id];
                    return [
                        'dev'     => 0,
                        'ino'     => 0,
                        'mode'    => $that->mode,
                        'nlink'   => 0,
                        'uid'     => $that->owner,
                        'gid'     => $that->group,
                        'rdev'    => 0,
                        'size'    => array_reduce((array) $that->content, fn($carry, $item) => $carry + strlen($item), 0),
                        'atime'   => $that->atime,
                        'mtime'   => $that->mtime,
                        'ctime'   => $that->ctime,
                        'blksize' => -1,
                        'blocks'  => -1,
                    ];
                }

                /** @noinspection PhpUnusedParameterInspection */
                public function stream_set_option(int $option, int $arg1, int $arg2)
                {
                    return false;
                }

                public function stream_open(string $path, string $mode, int $options, &$opened_path): bool
                {
                    assert(is_int($options));
                    assert(is_null($opened_path) || !strlen($opened_path));
                    $this->id = self::id($path);

                    // t フラグはクソなので実装しない（デフォルトで b フラグとする）
                    if (strpos($mode, 'r') !== false) {
                        // 普通の fopen でファイルが存在しないとエラーになるので模倣する
                        if (!isset(self::$entries[$this->id])) {
                            throw new \InvalidArgumentException("'$path' is not exist.");
                        }
                        $this->position = 0;
                        $this->appendable = false;
                    }
                    elseif (strpos($mode, 'w') !== false) {
                        // ファイルポインタをファイルの先頭に置き、ファイルサイズをゼロにします。
                        // ファイルが存在しない場合には、作成を試みます。
                        self::create($this->id, 010_0000);
                        $this->position = 0;
                        $this->appendable = false;
                    }
                    elseif (strpos($mode, 'a') !== false) {
                        // ファイルポインタをファイルの終端に置きます。
                        // ファイルが存在しない場合には、作成を試みます。
                        if (!isset(self::$entries[$this->id])) {
                            self::create($this->id, 010_0000);
                        }
                        $this->position = 0;
                        $this->appendable = true;
                    }
                    elseif (strpos($mode, 'x') !== false) {
                        // ファイルポインタをファイルの先頭に置きます。
                        // ファイルが既に存在する場合には fopen() は失敗し、 E_WARNING レベルのエラーを発行します。
                        // ファイルが存在しない場合には新規作成を試みます。
                        if (isset(self::$entries[$this->id])) {
                            throw new \InvalidArgumentException("'$path' is exist already.");
                        }
                        self::create($this->id, 010_0000);
                        $this->position = 0;
                        $this->appendable = false;
                    }
                    elseif (strpos($mode, 'c') !== false) {
                        // ファイルが存在しない場合には新規作成を試みます。
                        // ファイルが既に存在する場合でもそれを ('w' のように) 切り詰めたりせず、 また ('x' のように) 関数のコールが失敗することもありません。
                        // ファイルポインタをファイルの先頭に置きます。
                        if (!isset(self::$entries[$this->id])) {
                            self::create($this->id, 010_0000);
                        }
                        $this->position = 0;
                        $this->appendable = false;
                    }

                    $this->entry = self::$entries[$this->id];

                    return true;
                }

                public function stream_close()
                {
                }

                public function stream_lock(int $operation): bool
                {
                    assert(is_int($operation));
                    // メモリアクセスは競合しないので常に true を返す
                    return true;
                }

                public function stream_flush(): bool
                {
                    // バッファしないので常に true を返す
                    return true;
                }

                public function stream_eof(): bool
                {
                    return $this->position >= strlen($this->entry->content);
                }

                public function stream_read(int $count): string
                {
                    $result = substr($this->entry->content, $this->position, $count);
                    $this->position += strlen($result);
                    return $result;
                }

                public function stream_write(string $data): int
                {
                    $datalen = strlen($data);
                    $posision = $this->position;
                    // このモードは、fseek() では何の効果もありません。書き込みは、常に追記となります。
                    if ($this->appendable) {
                        $posision = strlen($this->entry->content);
                    }
                    // 一般的に、ファイルの終端より先の位置に移動することも許されています。
                    // そこにデータを書き込んだ場合、ファイルの終端からシーク位置までの範囲を読み込むと 値 0 が埋められたバイトを返します。
                    $current = str_pad($this->entry->content, $posision, "\0", STR_PAD_RIGHT);
                    $this->entry->content = substr_replace($current, $data, $posision, $datalen);
                    $this->position += $datalen;
                    return $datalen;
                }

                public function stream_truncate(int $new_size): bool
                {
                    $current = substr($this->entry->content, 0, $new_size);
                    $this->entry->content = str_pad($current, $new_size, "\0", STR_PAD_RIGHT);
                    return true;
                }

                public function stream_tell(): int
                {
                    return $this->position;
                }

                public function stream_seek(int $offset, int $whence = SEEK_SET): bool
                {
                    $strlen = strlen($this->entry->content);
                    switch ($whence) {
                        case SEEK_SET:
                            if ($offset < 0) {
                                return false;
                            }
                            $this->position = $offset;
                            break;

                        // stream_tell を定義していると SEEK_CUR が呼ばれない？（計算されて SEEK_SET に移譲されているような気がする）
                        // @codeCoverageIgnoreStart
                        case SEEK_CUR:
                            $this->position += $offset;
                            break;
                        // @codeCoverageIgnoreEnd

                        case SEEK_END:
                            $this->position = $strlen + $offset;
                            break;
                    }
                    // ファイルの終端から数えた位置に移動するには、負の値を offset に渡して whence を SEEK_END に設定しなければなりません。
                    if ($this->position < 0) {
                        $this->position = $strlen + $this->position;
                        if ($this->position < 0) {
                            $this->position = 0;
                            return false;
                        }
                    }
                    return true;
                }

                public function stream_stat()
                {
                    return self::stat($this->id);
                }

                public function stream_metadata($path, $option, $var)
                {
                    $id = self::id($path);
                    switch ($option) {
                        case STREAM_META_TOUCH:
                            if (!isset(self::$entries[$id])) {
                                self::create($id, 010_0000);
                            }
                            $mtime = $var[0] ?? time();
                            $atime = $var[1] ?? $mtime;
                            self::$entries[$id]->mtime = $mtime;
                            self::$entries[$id]->atime = $atime;
                            break;

                        case STREAM_META_ACCESS:
                            if (!isset(self::$entries[$id])) {
                                return false;
                            }
                            self::$entries[$id]->mode &= 077_0000;
                            self::$entries[$id]->mode |= $var & ~umask();
                            self::$entries[$id]->ctime = time();
                            break;

                        /** @noinspection PhpMissingBreakStatementInspection */
                        case STREAM_META_OWNER_NAME:
                            $nam = function_exists('posix_getpwnam') ? posix_getpwnam($var) : [];
                            $var = $nam['uid'] ?? 0;
                        case STREAM_META_OWNER:
                            if (!isset(self::$entries[$id])) {
                                return false;
                            }
                            self::$entries[$id]->owner = $var;
                            self::$entries[$id]->ctime = time();
                            break;

                        /** @noinspection PhpMissingBreakStatementInspection */
                        case STREAM_META_GROUP_NAME:
                            $var = function_exists('posix_getgrnam') ? posix_getgrnam($var)['gid'] : 0;
                        case STREAM_META_GROUP:
                            if (!isset(self::$entries[$id])) {
                                return false;
                            }
                            self::$entries[$id]->group = $var;
                            self::$entries[$id]->ctime = time();
                            break;
                    }
                    // https://qiita.com/hnw/items/3af76d3d7ec2cf52fff8
                    clearstatcache(true, $path);
                    return true;
                }

                public function url_stat(string $path, int $flags)
                {
                    assert(is_int($flags));
                    $id = self::id($path);
                    if (!isset(self::$entries[$id])) {
                        return false;
                    }
                    return self::stat($id);
                }

                public function rename(string $path_from, string $path_to): bool
                {
                    // rename は同じプロトコルじゃないと使えない制約があるのでプロトコルは見ないで OK
                    $id_from = self::id($path_from);
                    if (!isset(self::$entries[$id_from])) {
                        return false;
                    }
                    $id_to = self::id($path_to);
                    self::$entries[$id_to] = self::$entries[$id_from];
                    unset(self::$entries[$id_from]);
                    // https://qiita.com/hnw/items/3af76d3d7ec2cf52fff8
                    clearstatcache(true, $path_from);
                    return true;
                }

                public function unlink(string $path): bool
                {
                    $id = self::id($path);
                    if (!isset(self::$entries[$id])) {
                        return false;
                    }
                    unset(self::$entries[$id]);
                    // もしファイルを作成した場合、 たとえファイルを削除したとしても TRUE を返します。しかし、unlink() はキャッシュを自動的にクリアします。
                    clearstatcache(true, $path);
                    return true;
                }

                public function mkdir($path, $mode, $options)
                {
                    $id = self::id($path);
                    if (isset(self::$entries[$id])) {
                        return false;
                    }
                    $parts = explode('/', $id);
                    if (count($parts) > 1 && !($options & STREAM_MKDIR_RECURSIVE)) {
                        if (!isset(self::$entries[implode('/', array_slice($parts, 0, -1))])) {
                            return false;
                        }
                    }
                    $dirpath = '';
                    foreach ($parts as $part) {
                        $dirpath .= "$part/";
                        self::create(rtrim($dirpath, '/'), 004_0000 | $mode);
                    }
                    return true;
                }

                public function rmdir($path, $options)
                {
                    assert(is_int($options));
                    $id = self::id($path);
                    if (!isset(self::$entries[$id])) {
                        return false;
                    }
                    foreach (self::$entries as $eid => $entry) {
                        if (preg_match('#^' . preg_quote("$id/", '#') . '([^/]+)$#u', $eid)) {
                            return false;
                        }
                    }
                    unset(self::$entries[$id]);
                    clearstatcache(true, $path);
                    return true;
                }

                public function dir_opendir(string $path, int $options)
                {
                    assert(is_int($options));
                    $id = self::id($path);
                    if (!isset(self::$entries[$id])) {
                        return false;
                    }

                    $files = ['.', '..'];
                    foreach (self::$entries as $eid => $entry) {
                        if (preg_match('#^' . preg_quote("$id/", '#') . '([^/]+)$#u', $eid, $m)) {
                            $files[] = $m[1];
                        }
                    }

                    $this->entry = self::$entries[$id];
                    $this->entry->content = $files;
                    return true;
                }

                public function dir_readdir()
                {
                    $result = current($this->entry->content);
                    next($this->entry->content);
                    return $result;
                }

                public function dir_rewinddir()
                {
                    reset($this->entry->content);
                    return true;
                }

                public function dir_closedir()
                {
                    unset($this->entry);
                    return true;
                }
            }));
        }

        return "$STREAM_NAME://" . trim($path, '\\/');
    }
}
if (function_exists("ryunosuke\\PHPUnit\\memory_path") && !defined("ryunosuke\\PHPUnit\\memory_path")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\memory_path", "ryunosuke\\PHPUnit\\memory_path");
}

if (!isset($excluded_functions["delegate"]) && (!function_exists("ryunosuke\\PHPUnit\\delegate") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\delegate"))->isInternal()))) {
    /**
     * 指定 callable を指定クロージャで実行するクロージャを返す
     *
     * ほぼ内部向けで外から呼ぶことはあまり想定していない。
     *
     * @param \Closure $invoker クロージャを実行するためのクロージャ（実処理）
     * @param callable $callable 最終的に実行したいクロージャ
     * @param ?int $arity 引数の数
     * @return callable $callable を実行するクロージャ
     */
    function delegate($invoker, $callable, $arity = null)
    {
        $arity ??= parameter_length($callable, true, true);

        if (reflect_callable($callable)->isInternal()) {
            static $cache = [];
            $cache[(string) $arity] ??= evaluate('return new class()
            {
                private $invoker, $callable;

                public function spawn($invoker, $callable)
                {
                    $that = clone($this);
                    $that->invoker = $invoker;
                    $that->callable = $callable;
                    return $that;
                }

                public function __invoke(' . implode(',', is_infinite($arity)
                    ? ['...$_']
                    : array_map(fn($v) => '$_' . $v, array_keys(array_fill(1, $arity, null)))
                ) . ')
                {
                    return ($this->invoker)($this->callable, func_get_args());
                }
            };');
            return $cache[(string) $arity]->spawn($invoker, $callable);
        }

        switch (true) {
            case $arity === 0:
                return fn() => $invoker($callable, func_get_args());
            case $arity === 1:
                return fn($_1) => $invoker($callable, func_get_args());
            case $arity === 2:
                return fn($_1, $_2) => $invoker($callable, func_get_args());
            case $arity === 3:
                return fn($_1, $_2, $_3) => $invoker($callable, func_get_args());
            case $arity === 4:
                return fn($_1, $_2, $_3, $_4) => $invoker($callable, func_get_args());
            case $arity === 5:
                return fn($_1, $_2, $_3, $_4, $_5) => $invoker($callable, func_get_args());
            case is_infinite($arity):
                return fn(...$_) => $invoker($callable, func_get_args());
            default:
                $args = implode(',', array_map(fn($v) => '$_' . $v, array_keys(array_fill(1, $arity, null))));
                $stmt = 'return function (' . $args . ') use ($invoker, $callable) { return $invoker($callable, func_get_args()); };';
                return eval($stmt);
        }
    }
}
if (function_exists("ryunosuke\\PHPUnit\\delegate") && !defined("ryunosuke\\PHPUnit\\delegate")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\delegate", "ryunosuke\\PHPUnit\\delegate");
}

if (!isset($excluded_functions["ope_func"]) && (!function_exists("ryunosuke\\PHPUnit\\ope_func") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\ope_func"))->isInternal()))) {
    /**
     * 演算子のクロージャを返す
     *
     * 関数ベースなので `??` のような言語組み込みの特殊な演算子は若干希望通りにならない（Notice が出る）。
     * 2つ目以降の引数でオペランドを指定できる。
     *
     * Example:
     * ```php
     * $not = ope_func('!');    // 否定演算子クロージャ
     * that(false)->isSame($not(true));
     *
     * $minus = ope_func('-'); // マイナス演算子クロージャ
     * that($minus(2))->isSame(-2);       // 引数1つで呼ぶと1項演算子
     * that($minus(3, 2))->isSame(3 - 2); // 引数2つで呼ぶと2項演算子
     *
     * $cond = ope_func('?:'); // 条件演算子クロージャ
     * that($cond('OK', 'NG'))->isSame('OK' ?: 'NG');               // 引数2つで呼ぶと2項演算子
     * that($cond(false, 'OK', 'NG'))->isSame(false ? 'OK' : 'NG'); // 引数3つで呼ぶと3項演算子
     *
     * $gt5 = ope_func('<=', 5); // 5以下を判定するクロージャ
     * that(array_filter([1, 2, 3, 4, 5, 6, 7, 8, 9], $gt5))->isSame([1, 2, 3, 4, 5]);
     * ```
     *
     * @param string $operator 演算子
     * @param mixed ...$operands 右オペランド
     * @return \Closure 演算子のクロージャ
     */
    function ope_func($operator, ...$operands)
    {
        static $operators = null;
        $operators = $operators ?: [
            ''           => static fn($v1) => $v1, // こんな演算子はないが、「if ($value) {}」として使えることがある
            '!'          => static fn($v1) => !$v1,
            '+'          => static fn($v1, $v2 = null) => func_num_args() === 1 ? (+$v1) : ($v1 + $v2),
            '-'          => static fn($v1, $v2 = null) => func_num_args() === 1 ? (-$v1) : ($v1 - $v2),
            '~'          => static fn($v1) => ~$v1,
            '++'         => static fn(&$v1) => ++$v1,
            '--'         => static fn(&$v1) => --$v1,
            '?:'         => static fn($v1, $v2, $v3 = null) => func_num_args() === 2 ? ($v1 ?: $v2) : ($v1 ? $v2 : $v3),
            '??'         => static fn($v1, $v2) => $v1 ?? $v2,
            '=='         => static fn($v1, $v2) => $v1 == $v2,
            '==='        => static fn($v1, $v2) => $v1 === $v2,
            '!='         => static fn($v1, $v2) => $v1 != $v2,
            '<>'         => static fn($v1, $v2) => $v1 <> $v2,
            '!=='        => static fn($v1, $v2) => $v1 !== $v2,
            '<'          => static fn($v1, $v2) => $v1 < $v2,
            '<='         => static fn($v1, $v2) => $v1 <= $v2,
            '>'          => static fn($v1, $v2) => $v1 > $v2,
            '>='         => static fn($v1, $v2) => $v1 >= $v2,
            '<=>'        => static fn($v1, $v2) => $v1 <=> $v2,
            '.'          => static fn($v1, $v2) => $v1 . $v2,
            '*'          => static fn($v1, $v2) => $v1 * $v2,
            '/'          => static fn($v1, $v2) => $v1 / $v2,
            '%'          => static fn($v1, $v2) => $v1 % $v2,
            '**'         => static fn($v1, $v2) => $v1 ** $v2,
            '^'          => static fn($v1, $v2) => $v1 ^ $v2,
            '&'          => static fn($v1, $v2) => $v1 & $v2,
            '|'          => static fn($v1, $v2) => $v1 | $v2,
            '<<'         => static fn($v1, $v2) => $v1 << $v2,
            '>>'         => static fn($v1, $v2) => $v1 >> $v2,
            '&&'         => static fn($v1, $v2) => $v1 && $v2,
            '||'         => static fn($v1, $v2) => $v1 || $v2,
            'or'         => static fn($v1, $v2) => $v1 or $v2,
            'and'        => static fn($v1, $v2) => $v1 and $v2,
            'xor'        => static fn($v1, $v2) => $v1 xor $v2,
            'instanceof' => static fn($v1, $v2) => $v1 instanceof $v2,
            'new'        => static fn($v1, ...$v) => new $v1(...$v),
            'clone'      => static fn($v1) => clone $v1,
        ];

        $opefunc = $operators[trim($operator)] ?? throws(new \InvalidArgumentException("$operator is not defined Operator."));

        if ($operands) {
            return static fn($v1) => $opefunc($v1, ...$operands);
        }

        return $opefunc;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\ope_func") && !defined("ryunosuke\\PHPUnit\\ope_func")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\ope_func", "ryunosuke\\PHPUnit\\ope_func");
}

if (!isset($excluded_functions["eval_func"]) && (!function_exists("ryunosuke\\PHPUnit\\eval_func") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\eval_func"))->isInternal()))) {
    /**
     * 指定コードで eval するクロージャを返す
     *
     * create_function のクロージャ版みたいなもの。
     * 参照渡しは未対応。
     *
     * コード中の `$1`, `$2` 等の文字は `func_get_arg(1)` のような引数関数に変換される。
     *
     * Example:
     * ```php
     * $evalfunc = eval_func('$a + $b + $c', 'a', 'b', 'c');
     * that($evalfunc(1, 2, 3))->isSame(6);
     *
     * // $X による参照
     * $evalfunc = eval_func('$1 + $2 + $3');
     * that($evalfunc(1, 2, 3))->isSame(6);
     * ```
     *
     * @param string $expression eval コード
     * @param mixed ...$variadic 引数名（可変引数）
     * @return \Closure 新しいクロージャ
     */
    function eval_func($expression, ...$variadic)
    {
        static $cache = [];

        $args = array_sprintf($variadic, '$%s', ',');
        $cachekey = "$expression($args)";
        if (!isset($cache[$cachekey])) {
            $tmp = parse_php($expression, TOKEN_NAME);
            array_shift($tmp);
            $stmt = '';
            for ($i = 0; $i < count($tmp); $i++) {
                if (($tmp[$i][1] ?? null) === '$' && $tmp[$i + 1][0] === T_LNUMBER) {
                    $n = $tmp[$i + 1][1] - 1;
                    $stmt .= "func_get_arg($n)";
                    $i++;
                }
                else {
                    $stmt .= $tmp[$i][1];
                }
            }
            $cache[$cachekey] = eval("return function($args) { return $stmt; };");
        }
        return $cache[$cachekey];
    }
}
if (function_exists("ryunosuke\\PHPUnit\\eval_func") && !defined("ryunosuke\\PHPUnit\\eval_func")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\eval_func", "ryunosuke\\PHPUnit\\eval_func");
}

if (!isset($excluded_functions["reflect_callable"]) && (!function_exists("ryunosuke\\PHPUnit\\reflect_callable") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\reflect_callable"))->isInternal()))) {
    /**
     * callable から ReflectionFunctionAbstract を生成する
     *
     * Example:
     * ```php
     * that(reflect_callable('sprintf'))->isInstanceOf(\ReflectionFunction::class);
     * that(reflect_callable('\Closure::bind'))->isInstanceOf(\ReflectionMethod::class);
     * ```
     *
     * @param callable $callable 対象 callable
     * @return \ReflectionFunction|\ReflectionMethod リフレクションインスタンス
     */
    function reflect_callable($callable)
    {
        // callable チェック兼 $call_name 取得
        if (!is_callable($callable, true, $call_name)) {
            throw new \InvalidArgumentException("'$call_name' is not callable");
        }

        if ($callable instanceof \Closure || strpos($call_name, '::') === false) {
            return new \ReflectionFunction($callable);
        }
        else {
            [$class, $method] = explode('::', $call_name, 2);
            // for タイプ 5: 相対指定による静的クラスメソッドのコール (PHP 5.3.0 以降)
            if (strpos($method, 'parent::') === 0) {
                [, $method] = explode('::', $method);
                return (new \ReflectionClass($class))->getParentClass()->getMethod($method);
            }
            return new \ReflectionMethod($class, $method);
        }
    }
}
if (function_exists("ryunosuke\\PHPUnit\\reflect_callable") && !defined("ryunosuke\\PHPUnit\\reflect_callable")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\reflect_callable", "ryunosuke\\PHPUnit\\reflect_callable");
}

if (!isset($excluded_functions["callable_code"]) && (!function_exists("ryunosuke\\PHPUnit\\callable_code") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\callable_code"))->isInternal()))) {
    /**
     * callable のコードブロックを返す
     *
     * 返り値は2値の配列。0番目の要素が定義部、1番目の要素が処理部を表す。
     *
     * Example:
     * ```php
     * list($meta, $body) = callable_code(function (...$args) {return true;});
     * that($meta)->isSame('function (...$args)');
     * that($body)->isSame('{return true;}');
     *
     * // ReflectionFunctionAbstract を渡しても動作する
     * list($meta, $body) = callable_code(new \ReflectionFunction(function (...$args) {return true;}));
     * that($meta)->isSame('function (...$args)');
     * that($body)->isSame('{return true;}');
     * ```
     *
     * @param callable|\ReflectionFunctionAbstract $callable コードを取得する callable
     * @return array ['定義部分', '{処理コード}']
     */
    function callable_code($callable)
    {
        $ref = $callable instanceof \ReflectionFunctionAbstract ? $callable : reflect_callable($callable);
        $contents = file($ref->getFileName());
        $start = $ref->getStartLine();
        $end = $ref->getEndLine();
        $codeblock = implode('', array_slice($contents, $start - 1, $end - $start + 1));

        $meta = parse_php("<?php $codeblock", [
            'begin' => [T_FN, T_FUNCTION],
            'end'   => ['{', T_DOUBLE_ARROW],
        ]);
        $end = array_pop($meta);

        if ($end[0] === T_DOUBLE_ARROW) {
            $body = parse_php("<?php $codeblock", [
                'begin'  => T_DOUBLE_ARROW,
                'end'    => [';', ',', ')'],
                'offset' => last_key($meta),
                'greedy' => true,
            ]);
            $body = array_slice($body, 1, -1);
        }
        else {
            $body = parse_php("<?php $codeblock", [
                'begin'  => '{',
                'end'    => '}',
                'offset' => last_key($meta),
            ]);
        }

        return [trim(implode('', array_column($meta, 1))), trim(implode('', array_column($body, 1)))];
    }
}
if (function_exists("ryunosuke\\PHPUnit\\callable_code") && !defined("ryunosuke\\PHPUnit\\callable_code")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\callable_code", "ryunosuke\\PHPUnit\\callable_code");
}

if (!isset($excluded_functions["is_bindable_closure"]) && (!function_exists("ryunosuke\\PHPUnit\\is_bindable_closure") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\is_bindable_closure"))->isInternal()))) {
    /**
     * $this を bind 可能なクロージャか調べる
     *
     * Example:
     * ```php
     * that(is_bindable_closure(function () {}))->isTrue();
     * that(is_bindable_closure(static function () {}))->isFalse();
     * ```
     *
     * @param \Closure $closure 調べるクロージャ
     * @return bool $this を bind 可能なクロージャなら true
     */
    function is_bindable_closure(\Closure $closure)
    {
        return !!@$closure->bindTo(new \stdClass());
    }
}
if (function_exists("ryunosuke\\PHPUnit\\is_bindable_closure") && !defined("ryunosuke\\PHPUnit\\is_bindable_closure")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\is_bindable_closure", "ryunosuke\\PHPUnit\\is_bindable_closure");
}

if (!isset($excluded_functions["parameter_length"]) && (!function_exists("ryunosuke\\PHPUnit\\parameter_length") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\parameter_length"))->isInternal()))) {
    /**
     * callable の引数の数を返す
     *
     * クロージャはキャッシュされない。毎回リフレクションを生成し、引数の数を調べてそれを返す。
     * （クロージャには一意性がないので key-value なキャッシュが適用できない）。
     * ので、ループ内で使ったりすると目に見えてパフォーマンスが低下するので注意。
     *
     * Example:
     * ```php
     * // trim の引数は2つ
     * that(parameter_length('trim'))->isSame(2);
     * // trim の必須引数は1つ
     * that(parameter_length('trim', true))->isSame(1);
     * ```
     *
     * @param callable $callable 対象 callable
     * @param bool $require_only true を渡すと必須パラメータの数を返す
     * @param bool $thought_variadic 可変引数を考慮するか。 true を渡すと可変引数の場合に無限長を返す
     * @return int 引数の数
     */
    function parameter_length($callable, $require_only = false, $thought_variadic = false)
    {
        // クロージャの $call_name には一意性がないのでキャッシュできない（spl_object_hash でもいいが、かなり重複するので完全ではない）
        if ($callable instanceof \Closure) {
            /** @var \ReflectionFunctionAbstract $ref */
            $ref = reflect_callable($callable);
            if ($thought_variadic && $ref->isVariadic()) {
                return INF;
            }
            elseif ($require_only) {
                return $ref->getNumberOfRequiredParameters();
            }
            else {
                return $ref->getNumberOfParameters();
            }
        }

        // $call_name 取得
        is_callable($callable, false, $call_name);

        $cache = cache($call_name, function () use ($callable) {
            /** @var \ReflectionFunctionAbstract $ref */
            $ref = reflect_callable($callable);
            return [
                '00' => $ref->getNumberOfParameters(),
                '01' => $ref->isVariadic() ? INF : $ref->getNumberOfParameters(),
                '10' => $ref->getNumberOfRequiredParameters(),
                '11' => $ref->isVariadic() ? INF : $ref->getNumberOfRequiredParameters(),
            ];
        }, __FUNCTION__);
        return $cache[(int) $require_only . (int) $thought_variadic];
    }
}
if (function_exists("ryunosuke\\PHPUnit\\parameter_length") && !defined("ryunosuke\\PHPUnit\\parameter_length")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\parameter_length", "ryunosuke\\PHPUnit\\parameter_length");
}

if (!isset($excluded_functions["func_user_func_array"]) && (!function_exists("ryunosuke\\PHPUnit\\func_user_func_array") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\func_user_func_array"))->isInternal()))) {
    /**
     * パラメータ定義数に応じて呼び出し引数を可変にしてコールする
     *
     * デフォルト引数はカウントされない。必須パラメータの数で呼び出す。
     *
     * $callback に null を与えると例外的に「第1引数を返すクロージャ」を返す。
     *
     * php の標準関数は定義数より多い引数を投げるとエラーを出すのでそれを抑制したい場合に使う。
     *
     * Example:
     * ```php
     * // strlen に2つの引数を渡してもエラーにならない
     * $strlen = func_user_func_array('strlen');
     * that($strlen('abc', null))->isSame(3);
     * ```
     *
     * @param callable $callback 呼び出すクロージャ
     * @return callable 引数ぴったりで呼び出すクロージャ
     */
    function func_user_func_array($callback)
    {
        // null は第1引数を返す特殊仕様
        if ($callback === null) {
            return fn($v) => $v;
        }
        // クロージャはユーザ定義しかありえないので調べる必要がない
        if ($callback instanceof \Closure) {
            // と思ったが、\Closure::fromCallable で作成されたクロージャは内部属性が伝播されるようなので除外
            if (reflect_callable($callback)->isUserDefined()) {
                return $callback;
            }
        }

        // 上記以外は「引数ぴったりで削ぎ落としてコールするクロージャ」を返す
        $plength = parameter_length($callback, true, true);
        return delegate(function ($callback, $args) use ($plength) {
            if (is_infinite($plength)) {
                return $callback(...$args);
            }
            return $callback(...array_slice($args, 0, $plength));
        }, $callback, $plength);
    }
}
if (function_exists("ryunosuke\\PHPUnit\\func_user_func_array") && !defined("ryunosuke\\PHPUnit\\func_user_func_array")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\func_user_func_array", "ryunosuke\\PHPUnit\\func_user_func_array");
}

if (!isset($excluded_functions["function_parameter"]) && (!function_exists("ryunosuke\\PHPUnit\\function_parameter") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\function_parameter"))->isInternal()))) {
    /**
     * 関数/メソッドの引数定義を取得する
     *
     * ほぼ内部向けで外から呼ぶことはあまり想定していない。
     *
     * @param \ReflectionFunctionAbstract|callable $eitherReffuncOrCallable 関数/メソッドリフレクション or callable
     * @return array [引数名 => 引数宣言] の配列
     */
    function function_parameter($eitherReffuncOrCallable)
    {
        $reffunc = $eitherReffuncOrCallable instanceof \ReflectionFunctionAbstract
            ? $eitherReffuncOrCallable
            : reflect_callable($eitherReffuncOrCallable);

        $result = [];
        foreach ($reffunc->getParameters() as $parameter) {
            $declare = '';

            if ($parameter->hasType()) {
                $declare .= reflect_types($parameter->getType())->getName() . ' ';
            }

            if ($parameter->isPassedByReference()) {
                $declare .= '&';
            }

            if ($parameter->isVariadic()) {
                $declare .= '...';
            }

            $declare .= '$' . $parameter->getName();

            if ($parameter->isOptional()) {
                $defval = null;

                // 組み込み関数のデフォルト値を取得することは出来ない（isDefaultValueAvailable も false を返す）
                if ($parameter->isDefaultValueAvailable()) {
                    // 修飾なしでデフォルト定数が使われているとその名前空間で解決してしまうので場合分けが必要
                    if ($parameter->isDefaultValueConstant() && strpos($parameter->getDefaultValueConstantName(), '\\') === false) {
                        $defval = $parameter->getDefaultValueConstantName();
                    }
                    else {
                        $default = $parameter->getDefaultValue();
                        $defval = var_export2($default, true);
                        if (is_string($default)) {
                            $defval = strtr($defval, [
                                "\r" => "\\r",
                                "\n" => "\\n",
                                "\t" => "\\t",
                                "\f" => "\\f",
                                "\v" => "\\v",
                            ]);
                        }
                    }
                }
                // 「オプショナルだけどデフォルト値がないって有り得るのか？」と思ったが、上記の通り組み込み関数だと普通に有り得るようだ
                // notice が出るので記述せざるを得ないがその値を得る術がない。が、どうせ与えられないので null でいい
                elseif (version_compare(PHP_VERSION, 8.0) < 0) {
                    $defval = 'null';
                }

                if (isset($defval)) {
                    $declare .= ' = ' . $defval;
                }
            }

            $name = ($parameter->isPassedByReference() ? '&' : '') . '$' . $parameter->getName();
            $result[$name] = $declare;
        }

        return $result;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\function_parameter") && !defined("ryunosuke\\PHPUnit\\function_parameter")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\function_parameter", "ryunosuke\\PHPUnit\\function_parameter");
}

if (!isset($excluded_functions["mode"]) && (!function_exists("ryunosuke\\PHPUnit\\mode") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\mode"))->isInternal()))) {
    /**
     * 引数の最頻値を返す
     *
     * - 等価比較は文字列で行う。小数時は注意。おそらく php.ini の precision に従うはず
     * - 等価値が複数ある場合の返り値は不定
     * - 配列は個数ではなくフラット展開した要素を対象にする
     * - 候補がない場合はエラーではなく例外を投げる
     *
     * Example:
     * ```php
     * that(mode(0, 1, 2, 2, 3, 3, 3))->isSame(3);
     * ```
     *
     * @param mixed ...$variadic 対象の変数・配列・リスト
     * @return mixed 最頻値
     */
    function mode(...$variadic)
    {
        $args = array_flatten($variadic) or throws(new \LengthException("argument's length is 0."));
        $vals = array_map(function ($v) {
            if (is_object($v)) {
                // ここに特別扱いのオブジェクトを列挙していく
                if ($v instanceof \DateTimeInterface) {
                    return $v->getTimestamp();
                }
                // それ以外は stringify へ移譲（__toString もここに含まれている）
                return stringify($v);
            }
            return (string) $v;
        }, $args);
        $args = array_combine($vals, $args);
        $counts = array_count_values($vals);
        arsort($counts);
        reset($counts);
        return $args[key($counts)];
    }
}
if (function_exists("ryunosuke\\PHPUnit\\mode") && !defined("ryunosuke\\PHPUnit\\mode")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\mode", "ryunosuke\\PHPUnit\\mode");
}

if (!isset($excluded_functions["concat"]) && (!function_exists("ryunosuke\\PHPUnit\\concat") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\concat"))->isInternal()))) {
    /**
     * strcat の空文字回避版
     *
     * 基本は strcat と同じ。ただし、**引数の内1つでも空文字を含むなら空文字を返す**。
     *
     * 「プレフィックスやサフィックスを付けたいんだけど、空文字の場合はそのままで居て欲しい」という状況はまれによくあるはず。
     * コードで言えば `strlen($string) ? 'prefix-' . $string : '';` のようなもの。
     * 可変引数なので 端的に言えば mysql の CONCAT みたいな動作になる（あっちは NULL だが）。
     *
     * ```php
     * that(concat('prefix-', 'middle', '-suffix'))->isSame('prefix-middle-suffix');
     * that(concat('prefix-', '', '-suffix'))->isSame('');
     * ```
     *
     * @param mixed ...$variadic 結合する文字列（可変引数）
     * @return string 結合した文字列
     */
    function concat(...$variadic)
    {
        $result = '';
        foreach ($variadic as $s) {
            if (strlen($s = (string) $s) === 0) {
                return '';
            }
            $result .= $s;
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\concat") && !defined("ryunosuke\\PHPUnit\\concat")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\concat", "ryunosuke\\PHPUnit\\concat");
}

if (!isset($excluded_functions["quoteexplode"]) && (!function_exists("ryunosuke\\PHPUnit\\quoteexplode") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\quoteexplode"))->isInternal()))) {
    /**
     * エスケープやクオートに対応した explode
     *
     * $enclosures は配列で開始・終了文字が別々に指定できるが、実装上の都合で今のところ1文字ずつのみ。
     *
     * Example:
     * ```php
     * // シンプルな例
     * that(quoteexplode(',', 'a,b,c\\,d,"e,f"'))->isSame([
     *     'a', // 普通に分割される
     *     'b', // 普通に分割される
     *     'c\\,d', // \\ でエスケープしているので区切り文字とみなされない
     *     '"e,f"', // "" でクオートされているので区切り文字とみなされない
     * ]);
     *
     * // $enclosures で囲い文字の開始・終了文字を明示できる
     * that(quoteexplode(',', 'a,b,{e,f}', null, ['{' => '}']))->isSame([
     *     'a', // 普通に分割される
     *     'b', // 普通に分割される
     *     '{e,f}', // { } で囲まれているので区切り文字とみなされない
     * ]);
     * ```
     *
     * @param string|array $delimiter 分割文字列
     * @param string $string 対象文字列
     * @param ?int $limit 分割数。負数未対応
     * @param array|string $enclosures 囲い文字。 ["start" => "end"] で開始・終了が指定できる
     * @param string $escape エスケープ文字
     * @return array 分割された配列
     */
    function quoteexplode($delimiter, $string, $limit = null, $enclosures = "'\"", $escape = '\\')
    {
        if ($limit === null) {
            $limit = PHP_INT_MAX;
        }
        $limit = max(1, $limit);

        $delimiters = arrayize($delimiter);
        $current = 0;
        $result = [];
        for ($i = 0, $l = strlen($string); $i < $l; $i++) {
            if (count($result) === $limit - 1) {
                break;
            }
            $i = strpos_quoted($string, $delimiters, $i, $enclosures, $escape);
            if ($i === false) {
                break;
            }
            foreach ($delimiters as $delimiter) {
                $delimiterlen = strlen($delimiter);
                if (substr_compare($string, $delimiter, $i, $delimiterlen) === 0) {
                    $result[] = substr($string, $current, $i - $current);
                    $current = $i + $delimiterlen;
                    $i += $delimiterlen - 1;
                    break;
                }
            }
        }
        $result[] = substr($string, $current, $l);
        return $result;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\quoteexplode") && !defined("ryunosuke\\PHPUnit\\quoteexplode")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\quoteexplode", "ryunosuke\\PHPUnit\\quoteexplode");
}

if (!isset($excluded_functions["strpos_array"]) && (!function_exists("ryunosuke\\PHPUnit\\strpos_array") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\strpos_array"))->isInternal()))) {
    /**
     * 複数の文字列で strpos する
     *
     * $needles のそれぞれの位置を配列で返す。
     * ただし、見つからなかった文字は結果に含まれない。
     *
     * Example:
     * ```php
     * // 見つかった位置を返す
     * that(strpos_array('hello world', ['hello', 'world']))->isSame([
     *     0 => 0,
     *     1 => 6,
     * ]);
     * // 見つからない文字は含まれない
     * that(strpos_array('hello world', ['notfound', 'world']))->isSame([
     *     1 => 6,
     * ]);
     * ```
     *
     * @param string $haystack 対象文字列
     * @param iterable $needles 位置を取得したい文字列配列
     * @param int $offset 開始位置
     * @return array $needles それぞれの位置配列
     */
    function strpos_array($haystack, $needles, $offset = 0)
    {
        if ($offset < 0) {
            $offset += strlen($haystack);
        }

        $result = [];
        foreach (arrayval($needles, false) as $key => $needle) {
            $pos = strpos($haystack, $needle, $offset);
            if ($pos !== false) {
                $result[$key] = $pos;
            }
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\strpos_array") && !defined("ryunosuke\\PHPUnit\\strpos_array")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\strpos_array", "ryunosuke\\PHPUnit\\strpos_array");
}

if (!isset($excluded_functions["strpos_escaped"]) && (!function_exists("ryunosuke\\PHPUnit\\strpos_escaped") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\strpos_escaped"))->isInternal()))) {
    /**
     * エスケープを考慮して strpos する
     *
     * 文字列中のエスケープ中でない生の文字を検索する。
     * 例えば `"abc\nxyz"` という文字列で `"n"` という文字は存在しないとみなす。
     * `"\n"` は改行のエスケープシーケンスであり、 `"n"` という文字ではない（エスケープシーケンスとして "n" を流用しているだけ）。
     * 逆に `"\\n"` はバックスラッシュと `"n"` という文字であり `"n"` が存在する。
     * 簡単に言えば「直前にバックスラッシュがある場合はヒットしない strpos」である。
     * バックスラッシュは $escape 引数で指定可能。
     *
     * $needle 自体にエスケープ文字を含む場合、反対の意味で検索する。
     * つまり、「直前にバックスラッシュがある場合のみヒットする strpos」になる。
     *
     * $offset 引数を指定するとその位置から探索を開始するが、戻り読みはしないのでエスケープ文字の真っ只中を指定する場合は注意。
     * 例えば `"\n"` は改行文字だけであるが、offset に 1 に指定して "n" を探すとマッチする。
     *
     * Example:
     * ```php
     * # 分かりにくいので \ ではなく % をエスケープ文字とする
     * $defargs = [0, '%'];
     *
     * // これは false である（"%d" という文字の列であるため "d" という文字は存在しない）
     * that(strpos_escaped('%d', 'd', ...$defargs))->isSame(false);
     * // これは 2 である（"%" "d" という文字の列であるため（d の前の % は更にその前の % に呑まれておりメタ文字ではない））
     * that(strpos_escaped('%%d', 'd', ...$defargs))->isSame(2);
     *
     * // これは 0 である（% をつけて検索するとそのエスケープシーケンス的なものそのものを探すため）
     * that(strpos_escaped('%d', '%d', ...$defargs))->isSame(0);
     * // これは false である（"%" "d" という文字の列であるため "%d" という文字は存在しない）
     * that(strpos_escaped('%%d', '%d', ...$defargs))->isSame(false);
     * // これは 2 である（"%" "%d" という文字の列であるため）
     * that(strpos_escaped('%%%d', '%d', ...$defargs))->isSame(2);
     * ```
     *
     * @param string $haystack 対象文字列
     * @param string|array $needle 探す文字
     * @param int $offset 開始位置
     * @param string $escape エスケープ文字
     * @param ?string $found 見つかった文字が格納される
     * @return false|int 見つかった位置
     */
    function strpos_escaped($haystack, $needle, $offset = 0, $escape = '\\', &$found = null)
    {
        $q_escape = preg_quote($escape, '#');
        if (is_stringable($needle)) {
            $needle = preg_split("#($q_escape?.)#u", $needle, -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);
        }

        $needles = arrayval($needle);
        assert(!in_array($escape, $needles, true), sprintf('$needle must not contain only escape charactor ("%s")', implode(', ', $needles)));

        $matched = [];
        foreach (array_map(fn($c) => preg_quote($c, '#'), $needles) as $need) {
            if (preg_match_all("#((?:$q_escape)*?)($need)#u", $haystack, $matches, PREG_OFFSET_CAPTURE | PREG_SET_ORDER, $offset)) {
                foreach ($matches as [, $m_escape, $m_needle]) {
                    if ((strlen($m_escape[0]) / strlen($escape)) % 2 === 0) {
                        $matched[$m_needle[1]] ??= $m_needle[0];
                    }
                }
            }
        }
        if (!$matched) {
            $found = null;
            return false;
        }

        ksort($matched);
        $min = array_key_first($matched);
        $found = $matched[$min];
        return $min;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\strpos_escaped") && !defined("ryunosuke\\PHPUnit\\strpos_escaped")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\strpos_escaped", "ryunosuke\\PHPUnit\\strpos_escaped");
}

if (!isset($excluded_functions["strpos_quoted"]) && (!function_exists("ryunosuke\\PHPUnit\\strpos_quoted") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\strpos_quoted"))->isInternal()))) {
    /**
     * クオートを考慮して strpos する
     *
     * Example:
     * ```php
     * // クオート中は除外される
     * that(strpos_quoted('hello "this" is world', 'is'))->isSame(13);
     * // 開始位置やクオート文字は指定できる（5文字目以降の \* に囲まれていない hoge の位置を返す）
     * that(strpos_quoted('1:hoge, 2:*hoge*, 3:hoge', 'hoge', 5, '*'))->isSame(20);
     * ```
     *
     * @param string $haystack 対象文字列
     * @param string|iterable $needle 位置を取得したい文字列
     * @param int $offset 開始位置
     * @param string|array $enclosure 囲い文字。この文字中にいる $from, $to 文字は走査外になる
     * @param string $escape エスケープ文字。この文字が前にある $from, $to 文字は走査外になる
     * @param ?string $found $needle の内、見つかった文字列が格納される
     * @return false|int $needle の位置
     */
    function strpos_quoted($haystack, $needle, $offset = 0, $enclosure = "'\"", $escape = '\\', &$found = null)
    {
        if (is_string($enclosure)) {
            if (strlen($enclosure)) {
                $chars = str_split($enclosure);
                $enclosure = array_combine($chars, $chars);
            }
            else {
                $enclosure = [];
            }
        }
        $needles = arrayval($needle, false);

        $strlen = strlen($haystack);

        if ($offset < 0) {
            $offset += $strlen;
        }

        $found = null;
        $enclosing = [];
        for ($i = $offset; $i < $strlen; $i++) {
            if ($i !== 0 && $haystack[$i - 1] === $escape) {
                continue;
            }
            foreach ($enclosure as $start => $end) {
                if (substr_compare($haystack, $end, $i, strlen($end)) === 0) {
                    if ($enclosing && $enclosing[count($enclosing) - 1] === $end) {
                        array_pop($enclosing);
                        $i += strlen($end) - 1;
                        continue 2;
                    }
                }
                if (substr_compare($haystack, $start, $i, strlen($start)) === 0) {
                    $enclosing[] = $end;
                    $i += strlen($start) - 1;
                    continue 2;
                }
            }

            if (empty($enclosing)) {
                foreach ($needles as $needle) {
                    if (substr_compare($haystack, $needle, $i, strlen($needle)) === 0) {
                        $found = $needle;
                        return $i;
                    }
                }
            }
        }
        return false;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\strpos_quoted") && !defined("ryunosuke\\PHPUnit\\strpos_quoted")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\strpos_quoted", "ryunosuke\\PHPUnit\\strpos_quoted");
}

if (!isset($excluded_functions["strtr_escaped"]) && (!function_exists("ryunosuke\\PHPUnit\\strtr_escaped") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\strtr_escaped"))->isInternal()))) {
    /**
     * エスケープを考慮して strtr する
     *
     * 「エスケープ」についての詳細は strpos_escaped を参照。
     *
     * $replace_pairs は [from => to] な配列を指定する。
     * to がクロージャの場合はキーとオフセットでコールバックされる。
     *
     * strtr と同様、最も長いキーから置換を行い、置換後の文字列は対象にならない。
     *
     * Example:
     * ```php
     * # 分かりにくいので \ ではなく % をエスケープ文字とする
     * that((strtr_escaped)('XYZ ab %% %s', [
     *     'ab'  => 'AB',  // 2. 1 で置換された文字は対象にならない
     *     'A'   => '%a',  // 使われない
     *     'Z'   => '%z',  // 使われない
     *     '%%'  => 'p',   // 普通に置換される
     *     's'   => 'S',   // エスケープが対象なので置換されない（%s は文字 "s" ではない（\n が文字 "n" ではないのと同じ））
     *     'XYZ' => 'abc', // 1. 後ろにあるがまず置換される
     * ], '%'))->isSame('abc AB p %s');
     * ```
     *
     * @param string $string 対象文字列
     * @param array $replace_pairs 置換するペア
     * @param string $escape エスケープ文字
     * @return string 置換された文字列
     */
    function strtr_escaped($string, $replace_pairs, $escape = '\\')
    {
        uksort($replace_pairs, fn($a, $b) => strlen($b) - strlen($a));
        $froms = array_keys($replace_pairs);

        $offset = 0;
        while (($pos = strpos_escaped($string, $froms, $offset, $escape, $found)) !== false) {
            $to = $replace_pairs[$found];
            $replaced = $to instanceof \Closure ? $to($found, $pos) : $to;
            $string = substr_replace($string, $replaced, $pos, strlen($found));
            $offset = $pos + strlen($replaced);
        }
        return $string;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\strtr_escaped") && !defined("ryunosuke\\PHPUnit\\strtr_escaped")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\strtr_escaped", "ryunosuke\\PHPUnit\\strtr_escaped");
}

if (!isset($excluded_functions["str_equals"]) && (!function_exists("ryunosuke\\PHPUnit\\str_equals") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\str_equals"))->isInternal()))) {
    /**
     * 文字列比較の関数版
     *
     * 文字列以外が与えられた場合は常に false を返す。ただし __toString を実装したオブジェクトは別。
     *
     * Example:
     * ```php
     * that(str_equals('abc', 'abc'))->isTrue();
     * that(str_equals('abc', 'ABC', true))->isTrue();
     * that(str_equals('\0abc', '\0abc'))->isTrue();
     * ```
     *
     * @param string $str1 文字列1
     * @param string $str2 文字列2
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return bool 同じ文字列なら true
     */
    function str_equals($str1, $str2, $case_insensitivity = false)
    {
        // __toString 実装のオブジェクトは文字列化する（strcmp がそうなっているから）
        if (is_object($str1) && method_exists($str1, '__toString')) {
            $str1 = (string) $str1;
        }
        if (is_object($str2) && method_exists($str2, '__toString')) {
            $str2 = (string) $str2;
        }

        // この関数は === の関数版という位置づけなので例外は投げないで不一致とみなす
        if (!is_string($str1) || !is_string($str2)) {
            return false;
        }

        if ($case_insensitivity) {
            return strcasecmp($str1, $str2) === 0;
        }

        return $str1 === $str2;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\str_equals") && !defined("ryunosuke\\PHPUnit\\str_equals")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\str_equals", "ryunosuke\\PHPUnit\\str_equals");
}

if (!isset($excluded_functions["str_exists"]) && (!function_exists("ryunosuke\\PHPUnit\\str_exists") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\str_exists"))->isInternal()))) {
    /**
     * 指定文字列を含むか返す
     *
     * Example:
     * ```php
     * that(str_exists('abc', 'b'))->isTrue();
     * that(str_exists('abc', 'B', true))->isTrue();
     * that(str_exists('abc', ['b', 'x'], false, false))->isTrue();
     * that(str_exists('abc', ['b', 'x'], false, true))->isFalse();
     * ```
     *
     * @param string $haystack 対象文字列
     * @param string|array $needle 調べる文字列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @param bool $and_flag すべて含む場合に true を返すか
     * @return bool $needle を含むなら true
     */
    function str_exists($haystack, $needle, $case_insensitivity = false, $and_flag = false)
    {
        if (!is_array($needle)) {
            $needle = [$needle];
        }

        // あくまで文字列としての判定に徹する（strpos の第2引数は闇が深い気がする）
        $haystack = (string) $haystack;
        $needle = array_map('strval', $needle);

        foreach ($needle as $str) {
            if ($str === '') {
                continue;
            }
            $pos = $case_insensitivity ? stripos($haystack, $str) : strpos($haystack, $str);
            if ($and_flag && $pos === false) {
                return false;
            }
            if (!$and_flag && $pos !== false) {
                return true;
            }
        }
        return !!$and_flag;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\str_exists") && !defined("ryunosuke\\PHPUnit\\str_exists")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\str_exists", "ryunosuke\\PHPUnit\\str_exists");
}

if (!isset($excluded_functions["str_ellipsis"]) && (!function_exists("ryunosuke\\PHPUnit\\str_ellipsis") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\str_ellipsis"))->isInternal()))) {
    /**
     * 文字列を指定数に丸める
     *
     * mb_strimwidth と似ているが、省略文字の差し込み位置を $pos で指定できる。
     * $pos は負数が指定できる。負数の場合後ろから数えられる。
     * 省略した場合は真ん中となる。
     *
     * Example:
     * ```php
     * // 8文字に丸める（$pos 省略なので真ん中が省略される）
     * that(str_ellipsis('1234567890', 8, '...'))->isSame('12...890');
     * // 8文字に丸める（$pos=1 なので1文字目から省略される）
     * that(str_ellipsis('1234567890', 8, '...', 1))->isSame('1...7890');
     * // 8文字に丸める（$pos=-1 なので後ろから1文字目から省略される）
     * that(str_ellipsis('1234567890', 8, '...', -1))->isSame('1234...0');
     * ```
     *
     * @param string $string 対象文字列
     * @param int $width 丸める幅
     * @param string $trimmarker 省略文字列
     * @param int|null $pos 省略記号の差し込み位置
     * @return string 丸められた文字列
     */
    function str_ellipsis($string, $width, $trimmarker = '...', $pos = null)
    {
        $string = (string) $string;

        $strlen = mb_strlen($string);
        if ($strlen <= $width) {
            return $string;
        }

        $markerlen = mb_strlen($trimmarker);
        if ($markerlen >= $width) {
            return $trimmarker;
        }

        $length = $width - $markerlen;
        $pos ??= (int) ($length / 2);
        if ($pos < 0) {
            $pos += $length;
        }
        $pos = max(0, min($pos, $length));

        return mb_substr_replace($string, $trimmarker, $pos, $strlen - $length);
    }
}
if (function_exists("ryunosuke\\PHPUnit\\str_ellipsis") && !defined("ryunosuke\\PHPUnit\\str_ellipsis")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\str_ellipsis", "ryunosuke\\PHPUnit\\str_ellipsis");
}

if (!isset($excluded_functions["starts_with"]) && (!function_exists("ryunosuke\\PHPUnit\\starts_with") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\starts_with"))->isInternal()))) {
    /**
     * 指定文字列で始まるか調べる
     *
     * $with に配列を渡すといずれかで始まるときに true を返す。
     *
     * Example:
     * ```php
     * that(starts_with('abcdef', 'abc'))->isTrue();
     * that(starts_with('abcdef', 'ABC', true))->isTrue();
     * that(starts_with('abcdef', 'xyz'))->isFalse();
     * that(starts_with('abcdef', ['a', 'b', 'c']))->isTrue();
     * that(starts_with('abcdef', ['x', 'y', 'z']))->isFalse();
     * ```
     *
     * @param string $string 探される文字列
     * @param string|string[] $with 探す文字列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return bool 指定文字列で始まるなら true を返す
     */
    function starts_with($string, $with, $case_insensitivity = false)
    {
        assert(is_stringable($string));

        foreach ((array) $with as $w) {
            assert(strlen($w));

            if (str_equals(substr($string, 0, strlen($w)), $w, $case_insensitivity)) {
                return true;
            }
        }
        return false;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\starts_with") && !defined("ryunosuke\\PHPUnit\\starts_with")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\starts_with", "ryunosuke\\PHPUnit\\starts_with");
}

if (!isset($excluded_functions["namespace_split"]) && (!function_exists("ryunosuke\\PHPUnit\\namespace_split") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\namespace_split"))->isInternal()))) {
    /**
     * 文字列を名前空間とローカル名に区切ってタプルで返す
     *
     * class_namespace/class_shorten や function_shorten とほぼ同じだが下記の違いがある。
     *
     * - あくまで文字列として処理する
     *     - 例えば class_namespace は get_class されるが、この関数は（いうなれば） strval される
     * - \\ を trim しないし、特別扱いもしない
     *     - `ns\\hoge` と `\\ns\\hoge` で返り値が微妙に異なる
     *     - `ns\\` のような場合は名前空間だけを返す
     *
     * Example:
     * ```php
     * that(namespace_split('ns\\hoge'))->isSame(['ns', 'hoge']);
     * that(namespace_split('hoge'))->isSame(['', 'hoge']);
     * that(namespace_split('ns\\'))->isSame(['ns', '']);
     * that(namespace_split('\\hoge'))->isSame(['', 'hoge']);
     * ```
     *
     * @param string $string 対象文字列
     * @return array [namespace, localname]
     */
    function namespace_split($string)
    {
        $pos = strrpos($string, '\\');
        if ($pos === false) {
            return ['', $string];
        }
        return [substr($string, 0, $pos), substr($string, $pos + 1)];
    }
}
if (function_exists("ryunosuke\\PHPUnit\\namespace_split") && !defined("ryunosuke\\PHPUnit\\namespace_split")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\namespace_split", "ryunosuke\\PHPUnit\\namespace_split");
}

if (!isset($excluded_functions["paml_export"]) && (!function_exists("ryunosuke\\PHPUnit\\paml_export") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\paml_export"))->isInternal()))) {
    /**
     * 連想配列を paml 的文字列に変換する
     *
     * paml で出力することはまずないのでおまけ（import との対称性のために定義している）。
     *
     * Example:
     * ```php
     * that(paml_export([
     *     'n' => null,
     *     'f' => false,
     *     'i' => 123,
     *     'd' => 3.14,
     *     's' => 'this is string',
     * ]))->isSame('n: null, f: false, i: 123, d: 3.14, s: "this is string"');
     * ```
     *
     * @param array $pamlarray 配列
     * @param array $options オプション配列
     * @return string PAML 的文字列
     */
    function paml_export($pamlarray, $options = [])
    {
        $options += [
            'trailing-comma' => false,
            'pretty-space'   => true,
        ];

        $space = $options['pretty-space'] ? ' ' : '';

        $result = [];
        $n = 0;
        foreach ($pamlarray as $k => $v) {
            if (is_array($v)) {
                $inner = paml_export($v, $options);
                if (is_hasharray($v)) {
                    $v = '{' . $inner . '}';
                }
                else {
                    $v = '[' . $inner . ']';
                }
            }
            elseif ($v === null) {
                $v = 'null';
            }
            elseif ($v === false) {
                $v = 'false';
            }
            elseif ($v === true) {
                $v = 'true';
            }
            elseif (is_string($v)) {
                $v = '"' . addcslashes($v, "\"\0\\") . '"';
            }

            if ($k === $n++) {
                $result[] = "$v";
            }
            else {
                $result[] = "$k:{$space}$v";
            }
        }
        return implode(",$space", $result) . ($options['trailing-comma'] ? ',' : '');
    }
}
if (function_exists("ryunosuke\\PHPUnit\\paml_export") && !defined("ryunosuke\\PHPUnit\\paml_export")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\paml_export", "ryunosuke\\PHPUnit\\paml_export");
}

if (!isset($excluded_functions["str_array"]) && (!function_exists("ryunosuke\\PHPUnit\\str_array") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\str_array"))->isInternal()))) {
    /**
     * 文字列を区切り文字で区切って配列に変換する
     *
     * 典型的には http ヘッダとか sar の結果とかを配列にする。
     *
     * Example:
     * ```php
     * // http response header  を ":" 区切りで連想配列にする
     * that(str_array("
     * HTTP/1.1 200 OK
     * Content-Type: text/html; charset=utf-8
     * Connection: Keep-Alive
     * ", ':', true))->isSame([
     *     'HTTP/1.1 200 OK',
     *     'Content-Type' => 'text/html; charset=utf-8',
     *     'Connection'   => 'Keep-Alive',
     * ]);
     *
     * // sar の結果を " " 区切りで連想配列の配列にする
     * that(str_array("
     * 13:00:01        CPU     %user     %nice   %system   %iowait    %steal     %idle
     * 13:10:01        all      0.99      0.10      0.71      0.00      0.00     98.19
     * 13:20:01        all      0.60      0.10      0.56      0.00      0.00     98.74
     * ", ' ', false))->isSame([
     *     1 => [
     *         '13:00:01' => '13:10:01',
     *         'CPU'      => 'all',
     *         '%user'    => '0.99',
     *         '%nice'    => '0.10',
     *         '%system'  => '0.71',
     *         '%iowait'  => '0.00',
     *         '%steal'   => '0.00',
     *         '%idle'    => '98.19',
     *     ],
     *     2 => [
     *         '13:00:01' => '13:20:01',
     *         'CPU'      => 'all',
     *         '%user'    => '0.60',
     *         '%nice'    => '0.10',
     *         '%system'  => '0.56',
     *         '%iowait'  => '0.00',
     *         '%steal'   => '0.00',
     *         '%idle'    => '98.74',
     *     ],
     * ]);
     * ```
     *
     * @param string|array $string 対象文字列。配列を与えても動作する
     * @param string $delimiter 区切り文字
     * @param bool $hashmode 連想配列モードか
     * @return array 配列
     */
    function str_array($string, $delimiter, $hashmode)
    {
        $array = $string;
        if (is_stringable($string)) {
            $array = preg_split('#\R#u', $string, -1, PREG_SPLIT_NO_EMPTY);
        }
        $delimiter = preg_quote($delimiter, '#');

        $result = [];
        if ($hashmode) {
            foreach ($array as $n => $line) {
                $parts = preg_split("#$delimiter#u", $line, 2, PREG_SPLIT_NO_EMPTY);
                $key = isset($parts[1]) ? array_shift($parts) : $n;
                $result[trim($key)] = trim($parts[0]);
            }
        }
        else {
            foreach ($array as $n => $line) {
                $parts = preg_split("#$delimiter#u", $line, -1, PREG_SPLIT_NO_EMPTY);
                if (!isset($keys)) {
                    $keys = $parts;
                    continue;
                }
                $result[$n] = count($keys) === count($parts) ? array_combine($keys, $parts) : null;
            }
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\str_array") && !defined("ryunosuke\\PHPUnit\\str_array")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\str_array", "ryunosuke\\PHPUnit\\str_array");
}

if (!isset($excluded_functions["mb_substr_replace"]) && (!function_exists("ryunosuke\\PHPUnit\\mb_substr_replace") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\mb_substr_replace"))->isInternal()))) {
    /**
     * マルチバイト対応 substr_replace
     *
     * 本家は配列を与えたりできるが、ややこしいし使う気がしないので未対応。
     *
     * Example:
     * ```php
     * // 2文字目から5文字を「あいうえお」に置換する
     * that(mb_substr_replace('０１２３４５６７８９', 'あいうえお', 2, 5))->isSame('０１あいうえお７８９');
     * ```
     *
     * @param string $string 対象文字列
     * @param string $replacement 置換文字列
     * @param int $start 開始位置
     * @param ?int $length 置換長
     * @return string 置換した文字列
     */
    function mb_substr_replace($string, $replacement, $start, $length = null)
    {
        $string = (string) $string;

        $strlen = mb_strlen($string);
        if ($start < 0) {
            $start += $strlen;
        }
        if ($length === null) {
            $length = $strlen;
        }
        if ($length < 0) {
            $length += $strlen - $start;
        }

        return mb_substr($string, 0, $start) . $replacement . mb_substr($string, $start + $length);
    }
}
if (function_exists("ryunosuke\\PHPUnit\\mb_substr_replace") && !defined("ryunosuke\\PHPUnit\\mb_substr_replace")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\mb_substr_replace", "ryunosuke\\PHPUnit\\mb_substr_replace");
}

if (!isset($excluded_functions["mb_ellipsis"]) && (!function_exists("ryunosuke\\PHPUnit\\mb_ellipsis") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\mb_ellipsis"))->isInternal()))) {
    /**
     * 文字列を指定幅に丸める
     *
     * mb_strimwidth と機能的には同じだが、省略文字の差し込み位置を $pos で指定できる。
     * $pos は負数が指定できる。負数の場合後ろから数えられる。
     * 省略した場合は真ん中となる。
     *
     * Example:
     * ```php
     * // 10文字幅に丸める（$pos 省略なので真ん中が省略される）
     * that(mb_ellipsis('あいうえお1234567890', 10, '...'))->isSame('あい...890');
     * // 10文字幅に丸める（$pos=1 なので1幅目から省略される…が、1文字は「あ」なので前方に切られる）
     * that(mb_ellipsis('あいうえお1234567890', 10, '...', 1))->isSame('...567890');
     * // 10文字幅に丸める（$pos=2 なので2幅目から省略される）
     * that(mb_ellipsis('あいうえお1234567890', 10, '...', 2))->isSame('あ...67890');
     * // 10文字幅に丸める（$pos=-1 なので後ろから1幅目から省略される）
     * that(mb_ellipsis('あいうえお1234567890', 10, '...', -1))->isSame('あいう...0');
     * ```
     *
     * @param string $string 対象文字列
     * @param int $width 丸める幅
     * @param string $trimmarker 省略文字列
     * @param int|null $pos 省略記号の差し込み位置
     * @return string 丸められた文字列
     */
    function mb_ellipsis($string, $width, $trimmarker = '...', $pos = null)
    {
        $string = (string) $string;

        $strwidth = mb_strwidth($string);
        if ($strwidth <= $width) {
            return $string;
        }

        $markerwidth = mb_strwidth($trimmarker);
        if ($markerwidth >= $width) {
            return $trimmarker;
        }

        $maxwidth = $width - $markerwidth;
        $pos ??= $maxwidth / 2;
        if ($pos < 0) {
            $pos += $maxwidth;
        }
        $pos = ceil(max(0, min($pos, $maxwidth)));
        $end = $pos + $strwidth - $maxwidth;

        $widths = array_map('mb_strwidth', mb_str_split($string));
        $s = $e = null;
        $sum = 0;
        foreach ($widths as $n => $w) {
            $sum += $w;
            if (!isset($s) && $sum > $pos) {
                $s = $n;
            }
            if (!isset($e) && $sum >= $end) {
                $e = $n + 1;
            }
        }

        return mb_substr($string, 0, $s) . $trimmarker . mb_substr($string, $e);
    }
}
if (function_exists("ryunosuke\\PHPUnit\\mb_ellipsis") && !defined("ryunosuke\\PHPUnit\\mb_ellipsis")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\mb_ellipsis", "ryunosuke\\PHPUnit\\mb_ellipsis");
}

if (!isset($excluded_functions["evaluate"]) && (!function_exists("ryunosuke\\PHPUnit\\evaluate") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\evaluate"))->isInternal()))) {
    /**
     * eval のプロキシ関数
     *
     * 一度ファイルに吐いてから require した方が opcache が効くので抜群に速い。
     * また、素の eval は ParseError が起こったときの表示がわかりにくすぎるので少し見やすくしてある。
     *
     * 関数化してる以上 eval におけるコンテキストの引き継ぎはできない。
     * ただし、引数で変数配列を渡せるようにしてあるので get_defined_vars を併用すれば基本的には同じ（$this はどうしようもない）。
     *
     * 短いステートメントだと opcode が少ないのでファイルを経由せず直接 eval したほうが速いことに留意。
     * 一応引数で指定できるようにはしてある。
     *
     * Example:
     * ```php
     * $a = 1;
     * $b = 2;
     * $phpcode = ';
     * $c = $a + $b;
     * return $c * 3;
     * ';
     * that(evaluate($phpcode, get_defined_vars()))->isSame(9);
     * ```
     *
     * @param string $phpcode 実行する php コード
     * @param array $contextvars コンテキスト変数配列
     * @param int $cachesize キャッシュするサイズ
     * @return mixed eval の return 値
     */
    function evaluate($phpcode, $contextvars = [], $cachesize = 256)
    {
        $cachefile = null;
        if ($cachesize && strlen($phpcode) >= $cachesize) {
            $cachefile = function_configure('cachedir') . '/' . rawurlencode(__FUNCTION__) . '-' . sha1($phpcode) . '.php';
            if (!file_exists($cachefile)) {
                file_put_contents($cachefile, "<?php $phpcode", LOCK_EX);
            }
        }

        try {
            if ($cachefile) {
                /** @noinspection PhpMethodParametersCountMismatchInspection */
                return (static function () {
                    extract(func_get_arg(1));
                    return require func_get_arg(0);
                })($cachefile, $contextvars);
            }
            else {
                /** @noinspection PhpMethodParametersCountMismatchInspection */
                return (static function () {
                    extract(func_get_arg(1));
                    return eval(func_get_arg(0));
                })($phpcode, $contextvars);
            }
        }
        catch (\ParseError $ex) {
            $errline = $ex->getLine();
            $errline_1 = $errline - 1;
            $codes = preg_split('#\\R#u', $phpcode);
            $codes[$errline_1] = '>>> ' . $codes[$errline_1];

            $N = 5; // 前後の行数
            $message = $ex->getMessage();
            $message .= "\n" . implode("\n", array_slice($codes, max(0, $errline_1 - $N), $N * 2 + 1));
            if ($cachefile) {
                $message .= "\n in " . realpath($cachefile) . " on line " . $errline . "\n";
            }
            throw new \ParseError($message, $ex->getCode(), $ex);
        }
    }
}
if (function_exists("ryunosuke\\PHPUnit\\evaluate") && !defined("ryunosuke\\PHPUnit\\evaluate")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\evaluate", "ryunosuke\\PHPUnit\\evaluate");
}

if (!isset($excluded_functions["parse_php"]) && (!function_exists("ryunosuke\\PHPUnit\\parse_php") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\parse_php"))->isInternal()))) {
    /**
     * php のコード断片をパースする
     *
     * 結果配列は token_get_all したものだが、「字句の場合に文字列で返す」仕様は適用されずすべて配列で返す。
     * つまり必ず `[TOKENID, TOKEN, LINE, POS]` で返す。
     *
     * @todo 現在の仕様では php タグが自動で付与されるが、標準と異なり直感的ではないのでその仕様は除去する
     * @todo そもそも何がしたいのかよくわからない関数になってきたので動作の洗い出しが必要
     *
     * Example:
     * ```php
     * $phpcode = 'namespace Hogera;
     * class Example
     * {
     *     // something
     * }';
     *
     * // namespace ～ ; を取得
     * $part = parse_php($phpcode, [
     *     'begin' => T_NAMESPACE,
     *     'end'   => ';',
     * ]);
     * that(implode('', array_column($part, 1)))->isSame('namespace Hogera;');
     *
     * // class ～ { を取得
     * $part = parse_php($phpcode, [
     *     'begin' => T_CLASS,
     *     'end'   => '{',
     * ]);
     * that(implode('', array_column($part, 1)))->isSame("class Example\n{");
     * ```
     *
     * @param string $phpcode パースする php コード
     * @param array|int $option パースオプション
     * @return array トークン配列
     */
    function parse_php($phpcode, $option = [])
    {
        if (is_int($option)) {
            $option = ['flags' => $option];
        }

        $default = [
            'phptag'         => true, // 初めに php タグを付けるか
            'short_open_tag' => null, // ショートオープンタグを扱うか（null だと余計なことはせず ini に従う）
            'line'           => [],   // 行の範囲（以上以下）
            'position'       => [],   // 文字位置の範囲（以上以下）
            'begin'          => [],   // 開始トークン
            'end'            => [],   // 終了トークン
            'offset'         => 0,    // 開始トークン位置
            'flags'          => 0,    // token_get_all の $flags. TOKEN_PARSE を与えると ParseError が出ることがあるのでデフォルト 0
            'cache'          => true, // キャッシュするか否か
            'greedy'         => false,// end と nest か一致したときに処理を継続するか
            'nest_token'     => [
                ')' => '(',
                '}' => '{',
                ']' => '[',
            ],
        ];
        $option += $default;

        $cachekey = var_hash($phpcode) . $option['flags'] . '-' . $option['phptag'] . '-' . var_export($option['short_open_tag'], true);
        static $cache = [];
        if (!($option['cache'] && isset($cache[$cachekey]))) {
            $phptag = $option['phptag'] ? '<?php ' : '';
            $phpcode = $phptag . $phpcode;
            $position = -strlen($phptag);

            $tokens = [];
            $tmp = token_get_all($phpcode, $option['flags']);
            for ($i = 0; $i < count($tmp); $i++) {
                $token = $tmp[$i];

                // token_get_all の結果は微妙に扱いづらいので少し調整する（string/array だったり、名前変換の必要があったり）
                if (!is_array($token)) {
                    $last = $tokens[count($tokens) - 1] ?? [null, 1, 0];
                    $token = [ord($token), $token, $last[2] + preg_match_all('/(?:\r\n|\r|\n)/', $last[1])];
                }

                // @codeCoverageIgnoreStart
                if ($option['short_open_tag'] === true && $token[0] === T_INLINE_HTML && ($p = strpos($token[1], '<?')) !== false) {
                    $newtokens = [];
                    $nlcount = 0;

                    if ($p !== 0) {
                        $html = substr($token[1], 0, $p);
                        $nlcount = preg_match_all('#\r\n|\r|\n#u', $html);
                        $newtokens[] = [T_INLINE_HTML, $html, $token[2]];
                    }

                    $code = substr($token[1], $p + 2);
                    $subtokens = token_get_all("<?php $code");
                    $subtokens[0][1] = '<?';
                    foreach ($subtokens as $subtoken) {
                        if (is_array($subtoken)) {
                            $subtoken[2] += $token[2] + $nlcount - 1;
                        }
                        $newtokens[] = $subtoken;
                    }

                    array_splice($tmp, $i + 1, 0, $newtokens);
                    continue;
                }
                if ($option['short_open_tag'] === false && $token[0] === T_OPEN_TAG && $token[1] === '<?') {
                    for ($j = $i + 1; $j < count($tmp); $j++) {
                        if ($tmp[$j][0] === T_CLOSE_TAG) {
                            break;
                        }
                    }
                    $html = implode('', array_map(fn($token) => is_array($token) ? $token[1] : $token, array_slice($tmp, $i, $j - $i + 1)));
                    array_splice($tmp, $i + 1, $j - $i, [[T_INLINE_HTML, $html, $token[2]]]);
                    continue;
                }
                // @codeCoverageIgnoreEnd

                $token[] = $position;
                if ($option['flags'] & TOKEN_NAME) {
                    $token[] = token_name($token[0]);
                }

                $position += strlen($token[1]);
                $tokens[] = $token;
            }
            // @codeCoverageIgnoreStart
            if ($option['short_open_tag'] === false) {
                for ($i = 0; $i < count($tokens); $i++) {
                    if ($tokens[$i][0] === T_INLINE_HTML && isset($tokens[$i + 1]) && $tokens[$i + 1][0] === T_INLINE_HTML) {
                        $tokens[$i][1] .= $tokens[$i + 1][1];
                        array_splice($tokens, $i + 1, 1, []);
                        $i--;
                    }
                }
            }
            // @codeCoverageIgnoreEnd
            $cache[$cachekey] = $tokens;
        }
        $tokens = $cache[$cachekey];

        $lines = $option['line'] + [-PHP_INT_MAX, PHP_INT_MAX];
        $positions = $option['position'] + [-PHP_INT_MAX, PHP_INT_MAX];
        $begin_tokens = (array) $option['begin'];
        $end_tokens = (array) $option['end'];
        $nest_tokens = $option['nest_token'];
        $greedy = $option['greedy'];

        $result = [];
        $starting = !$begin_tokens;
        $nesting = 0;
        $offset = is_array($option['offset']) ? ($option['offset'][0] ?? 0) : $option['offset'];
        $endset = is_array($option['offset']) ? ($option['offset'][1] ?? count($tokens)) : count($tokens);

        for ($i = $offset; $i < $endset; $i++) {
            $token = $tokens[$i];

            if ($lines[0] > $token[2]) {
                continue;
            }
            if ($lines[1] < $token[2]) {
                continue;
            }
            if ($positions[0] > $token[3]) {
                continue;
            }
            if ($positions[1] < $token[3]) {
                continue;
            }

            foreach ($begin_tokens as $t) {
                if ($t === $token[0] || $t === $token[1]) {
                    $starting = true;
                    break;
                }
            }
            if (!$starting) {
                continue;
            }

            $result[$i] = $token;

            foreach ($nest_tokens as $end_nest => $start_nest) {
                if ($token[0] === $start_nest || $token[1] === $start_nest) {
                    $nesting++;
                }
                if ($token[0] === $end_nest || $token[1] === $end_nest) {
                    $nesting--;
                }
            }

            foreach ($end_tokens as $t) {
                if ($t === $token[0] || $t === $token[1]) {
                    if ($nesting <= 0 || ($nesting === 1 && in_array($t, $nest_tokens, true))) {
                        if ($nesting === 0 && $greedy && isset($nest_tokens[$t])) {
                            break;
                        }
                        break 2;
                    }
                    break;
                }
            }
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\parse_php") && !defined("ryunosuke\\PHPUnit\\parse_php")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\parse_php", "ryunosuke\\PHPUnit\\parse_php");
}

if (!isset($excluded_functions["indent_php"]) && (!function_exists("ryunosuke\\PHPUnit\\indent_php") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\indent_php"))->isInternal()))) {
    /**
     * php のコードのインデントを調整する
     *
     * baseline で基準インデント位置を指定する。
     * その基準インデントを削除した後、指定したインデントレベルでインデントするようなイメージ。
     *
     * Example:
     * ```php
     * $phpcode = '
     *     echo 123;
     *
     *     if (true) {
     *         echo 456;
     *     }
     * ';
     * // 数値指定は空白換算
     * that(indent_php($phpcode, 8))->isSame('
     *         echo 123;
     *
     *         if (true) {
     *             echo 456;
     *         }
     * ');
     * // 文字列を指定すればそれが使用される
     * that(indent_php($phpcode, "  "))->isSame('
     *   echo 123;
     *
     *   if (true) {
     *       echo 456;
     *   }
     * ');
     * // オプション指定
     * that(indent_php($phpcode, [
     *     'baseline'  => 1,    // 基準インデントの行番号（負数で下からの指定になる）
     *     'indent'    => 4,    // インデント指定（上記の数値・文字列指定はこれの糖衣構文）
     *     'trimempty' => true, // 空行を trim するか
     *     'heredoc'   => true, // Flexible Heredoc もインデントするか
     * ]))->isSame('
     *     echo 123;
     *
     *     if (true) {
     *         echo 456;
     *     }
     * ');
     * ```
     *
     * @param string $phpcode インデントする php コード
     * @param array|int|string $options オプション
     * @return string インデントされた php コード
     */
    function indent_php($phpcode, $options = [])
    {
        if (!is_array($options)) {
            $options = ['indent' => $options];
        }
        $options += [
            'baseline'  => 1,
            'indent'    => 0,
            'trimempty' => true,
            'heredoc'   => true,
        ];
        if (is_int($options['indent'])) {
            $options['indent'] = str_repeat(' ', $options['indent']);
        }

        $lines = preg_split('#\\R#u', $phpcode);
        $baseline = $options['baseline'];
        if ($baseline < 0) {
            $baseline = count($lines) + $baseline;
        }
        preg_match('@^[ \t]*@u', $lines[$baseline] ?? '', $matches);
        $indent = $matches[0] ?? '';

        $tmp = token_get_all("<?php $phpcode");
        array_shift($tmp);

        // トークンの正規化
        $tokens = [];
        for ($i = 0; $i < count($tmp); $i++) {
            if (is_string($tmp[$i])) {
                $tmp[$i] = [-1, $tmp[$i], null];
            }

            // 行コメントの分割（T_COMMENT には改行が含まれている）
            if ($tmp[$i][0] === T_COMMENT && preg_match('@^(#|//).*?(\\R)@um', $tmp[$i][1], $matches)) {
                $tmp[$i][1] = trim($tmp[$i][1]);
                if (($tmp[$i + 1][0] ?? null) === T_WHITESPACE) {
                    $tmp[$i + 1][1] = $matches[2] . $tmp[$i + 1][1];
                }
                else {
                    array_splice($tmp, $i + 1, 0, [[T_WHITESPACE, $matches[2], null]]);
                }
            }

            if ($options['heredoc']) {
                // 行コメントと同じ（T_START_HEREDOC には改行が含まれている）
                if ($tmp[$i][0] === T_START_HEREDOC && preg_match('@^(<<<).*?(\\R)@um', $tmp[$i][1], $matches)) {
                    $tmp[$i][1] = trim($tmp[$i][1]);
                    if (($tmp[$i + 1][0] ?? null) === T_ENCAPSED_AND_WHITESPACE) {
                        $tmp[$i + 1][1] = $matches[2] . $tmp[$i + 1][1];
                    }
                    else {
                        array_splice($tmp, $i + 1, 0, [[T_ENCAPSED_AND_WHITESPACE, $matches[2], null]]);
                    }
                }
                // php 7.3 において T_END_HEREDOC は必ず単一行になる
                if ($tmp[$i][0] === T_ENCAPSED_AND_WHITESPACE) {
                    if (($tmp[$i + 1][0] ?? null) === T_END_HEREDOC && preg_match('@^(\\s+)(.*)@um', $tmp[$i + 1][1], $matches)) {
                        $tmp[$i][1] = $tmp[$i][1] . $matches[1];
                        $tmp[$i + 1][1] = $matches[2];
                    }
                }
            }

            $tokens[] = $tmp[$i] + [3 => token_name($tmp[$i][0])];
        }

        // 改行を置換してインデント
        $hereing = false;
        foreach ($tokens as $i => $token) {
            if ($options['heredoc']) {
                if ($token[0] === T_START_HEREDOC) {
                    $hereing = true;
                }
                if ($token[0] === T_END_HEREDOC) {
                    $hereing = false;
                }
            }
            if (in_array($token[0], [T_WHITESPACE, T_COMMENT, T_DOC_COMMENT], true) || ($hereing && $token[0] === T_ENCAPSED_AND_WHITESPACE)) {
                $token[1] = preg_replace("@(\\R)$indent@um", '$1' . $options['indent'], $token[1]);
            }
            if ($options['trimempty']) {
                if ($token[0] === T_WHITESPACE) {
                    $token[1] = preg_replace("@(\\R)[ \\t]+(\\R)@um", '$1$2', $token[1]);
                }
            }

            $tokens[$i] = $token;
        }
        return implode('', array_column($tokens, 1));
    }
}
if (function_exists("ryunosuke\\PHPUnit\\indent_php") && !defined("ryunosuke\\PHPUnit\\indent_php")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\indent_php", "ryunosuke\\PHPUnit\\indent_php");
}

if (!isset($excluded_functions["chain"]) && (!function_exists("ryunosuke\\PHPUnit\\chain") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\chain"))->isInternal()))) {
    /**
     * 関数をメソッドチェーンできるオブジェクトを返す
     *
     * ChainObject という関数をチェーンできるオブジェクトを返す。
     * ChainObject は大抵のグローバル関数がアノテーションされており、コード補完することが出来る（利便性のためであり、IDE がエラーなどを出しても呼び出し自体は可能）。
     * 呼び出しは「第1引数に現在の値が適用」されて実行される（下記の func[X] コールで任意の位置に適用されることもできる）。
     *
     * 下記の特殊ルールにより、特殊な呼び出し方ができる。
     *
     * - nullsafe 設定にすると「値が null の場合は呼び出し自体を行わない」という動作になり null をそのまま返す
     * - array_XXX, str_XXX は省略して XXX で呼び出せる
     *   - 省略した結果、他の関数と被る場合は可能な限り型で一致する呼び出しを行う
     * - func(..., _, ...) で _ で「値があたる位置」を明示できる
     *   - `str_replace('from', 'to', _)` のように呼び出せる
     * - func[1] で「引数1（0 ベースなので要は2番目）に適用して func を呼び出す」ことができる
     *   - func[2], func[3] 等も呼び出し可能
     * - func['E'] で eval される文字列のクロージャを呼べる
     *   - 引数名は `$1`, `$2` のような文字列で指定できる
     *   - `$X` が無いときに限り 最左に `$1` が自動付与される
     * - 引数が1つの呼び出しは () を省略できる
     *
     * この特殊ルールは普通に使う分にはそこまで気にしなくて良い。
     * map や filter を駆使しようとすると必要になるが、イテレーション目的ではなく文字列のチェインなどが目的であればほぼ使うことはない。
     *
     * 上記を含むメソッド呼び出しはすべて自分自身を返すので、最終結果を得たい場合は `invoke` を実行する必要がある。
     * ただし、 IteratorAggregate が実装されているので、配列の場合に限り foreach で直接回すことができる。
     * その他、 Stringable や Countable, JsonSerializable など「値が必要になりそうなインターフェース」が実装されている。
     *
     * 用途は配列のイテレーションを想定しているが、あくまで「チェイン可能にする」が目的なので、ソースが文字列だろうとオブジェクトだろうと何でも呼び出しが可能。
     * ただし、遅延評価も最適化も何もしていないので、 chain するだけでも動作は相当遅くなることに注意。
     *
     * Example:
     * ```php
     * # 1～9 のうち「5以下を抽出」して「値を2倍」して「合計」を出すシチュエーション
     * $n1_9 = range(1, 9);
     * // 素の php で処理したもの。パッと見で何してるか分からないし、処理の順番が思考と逆なので混乱する
     * that(array_sum(array_map(fn($v) => $v * 2, array_filter($n1_9, fn($v) => $v <= 5))))->isSame(30);
     * // chain でクロージャを渡したもの。処理の順番が思考どおりだが、 fn() が微妙にうざい（array_ は省略できるので filter, map, sum のような呼び出しができている）
     * that(chain($n1_9)->filter(fn($v) => $v <= 5)->maps(fn($v) => $v * 2)->sum()())->isSame(30);
     * // func['E'] を介したもの。かなり直感的だが eval なので少し不安
     * that(chain($n1_9)->filter['E']('<= 5')->maps['E']('* 2')->sum()())->isSame(30);
     *
     * # "hello   world" を「" " で分解」して「空文字を除去」してそれぞれに「ucfirst」して「"/" で結合」して「rot13」して「md5」して「大文字化」するシチュエーション
     * $string = 'hello   world';
     * // 素の php で処理したもの。もはやなにがなんだか分からない
     * that(strtoupper(md5(str_rot13(implode('/', array_map('ucfirst', array_filter(explode(' ', $string))))))))->isSame('10AF4DAF67D0D666FCEA0A8C6EF57EE7');
     * // chain だとかなりそれっぽくできる。 explode/implode の第1引数は区切り文字なので func[1] 構文を使用している。また、 rot13 以降は引数がないので () を省略している
     * that(chain($string)->explode[1](' ')->filter()->maps('ucfirst')->implode[1]('/')->rot13->md5->strtoupper()())->isSame('10AF4DAF67D0D666FCEA0A8C6EF57EE7');
     *
     *  # よくある DB レコードをあれこれするシチュエーション
     * $rows = [
     *     ['id' => 1, 'name' => 'hoge', 'sex' => 'F', 'age' => 17, 'salary' => 230000],
     *     ['id' => 3, 'name' => 'fuga', 'sex' => 'M', 'age' => 43, 'salary' => 480000],
     *     ['id' => 7, 'name' => 'piyo', 'sex' => 'M', 'age' => 21, 'salary' => 270000],
     *     ['id' => 9, 'name' => 'hage', 'sex' => 'F', 'age' => 30, 'salary' => 320000],
     * ];
     * // e.g. 男性の平均給料
     * that(chain($rows)->where['E']('sex', '=== "M"')->column('salary')->mean()())->isSame(375000);
     * // e.g. 女性の平均年齢
     * that(chain($rows)->where['E']('sex', '=== "F"')->column('age')->mean()())->isSame(23.5);
     * // e.g. 30歳以上の平均給料
     * that(chain($rows)->where['E']('age', '>= 30')->column('salary')->mean()())->isSame(400000);
     * // e.g. 20～30歳の平均給料
     * that(chain($rows)->where['E']('age', '>= 20')->where['E']('age', '<= 30')->column('salary')->mean()())->isSame(295000);
     * // e.g. 男性の最小年齢
     * that(chain($rows)->where['E']('sex', '=== "M"')->column('age')->min()())->isSame(21);
     * // e.g. 女性の最大給料
     * that(chain($rows)->where['E']('sex', '=== "F"')->column('salary')->max()())->isSame(320000);
     * ```
     *
     * @param mixed $source 元データ
     * @return \ChainObject
     */
    function chain($source = null)
    {
        if (function_configure('chain.version') === 2) {
            return new class($source) implements \Countable, \ArrayAccess, \IteratorAggregate, \JsonSerializable {
                private static $metadata = [];

                private $data;
                private $callback;

                public function __construct($source)
                {
                    $this->data = $source;
                }

                public function __get($name)
                {
                    $this->data = $this();

                    $this->callback = $this->_resolve($name, $this->data);
                    return $this;
                }

                public function __call($name, $arguments)
                {
                    return $this->$name[0](...$arguments);
                }

                public function __invoke()
                {
                    return $this[0]()->data;
                }

                public function __toString()
                {
                    return (string) $this();
                }

                public function getIterator(): \Traversable
                {
                    yield from $this();
                }

                public function count(): int
                {
                    return count($this());
                }

                /** @noinspection PhpLanguageLevelInspection */
                #[\ReturnTypeWillChange]
                public function jsonSerialize()
                {
                    return $this();
                }

                public function offsetGet($offset): callable
                {
                    return function (...$arguments) use ($offset) {
                        if ($this->callback !== null) {
                            // E モード
                            if ($offset === 'E') {
                                $offset = 0;
                                $expr = array_pop($arguments);
                                $expr = preg_match('#\$\d+#u', $expr) ? $expr : '$1 ' . $expr;
                                $arguments[] = eval_func($expr, '_');
                            }

                            $this->data = $this->_apply($this->callback, $arguments, [$offset => $this->data]);
                            $this->callback = null;
                        }
                        return $this;
                    };
                }

                public function apply($callback, ...$args)
                {
                    $this->data = $callback($this->data, ...$args);
                    return $this;
                }

                // @codeCoverageIgnoreStart

                public function offsetExists($offset): bool { throw new \LogicException(__METHOD__ . ' is not supported'); }

                public function offsetSet($offset, $value): void { throw new \LogicException(__METHOD__ . ' is not supported'); }

                public function offsetUnset($offset): void { throw new \LogicException(__METHOD__ . ' is not supported'); }

                // @codeCoverageIgnoreEnd

                private static function _resolve($name, $data)
                {
                    $isiterable = is_iterable($data);
                    $isstringable = is_stringable($data);
                    if (false
                        // for global
                        || (is_callable($name, false, $fname))
                        || ($isiterable && is_callable("array_$name", false, $fname))
                        || ($isstringable && is_callable("str_$name", false, $fname))
                        // for package
                        || (defined($cname = $name) && is_callable(constant($cname), false, $fname))
                        || ($isiterable && defined($cname = "array_$name") && is_callable(constant($cname), false, $fname))
                        || ($isstringable && defined($cname = "str_$name") && is_callable(constant($cname), false, $fname))
                        // for namespace
                        || (defined($cname = __NAMESPACE__ . "\\$name") && is_callable(constant($cname), false, $fname))
                        || ($isiterable && defined($cname = __NAMESPACE__ . "\\array_$name") && is_callable(constant($cname), false, $fname))
                        || ($isstringable && defined($cname = __NAMESPACE__ . "\\str_$name") && is_callable(constant($cname), false, $fname))
                    ) {
                        return $fname;
                    }

                    throw new \BadFunctionCallException("function '$name' is not defined");
                }

                private static function _apply($callback, $arguments, $injections)
                {
                    // 必要なメタデータを採取してキャッシュしておく
                    $metadata = self::$metadata[$callback] ??= (function ($callback) {
                        $reffunc = reflect_callable($callback);
                        $parameters = $reffunc->getParameters();
                        $metadata = [
                            // 可変長パラメータを無限に返す generator（適切に break しないと無限ループしてしまうので 999 個までとしてある）
                            'parameters' => function () use ($parameters) {
                                foreach ($parameters as $parameter) {
                                    if ($parameter->isVariadic()) {
                                        for ($i = 0; 999; $i++) {
                                            yield $parameter->getPosition() + $i => $parameter;
                                        }
                                        throw new \ArgumentCountError("parameter length is too long(>=$i)"); // @codeCoverageIgnore
                                    }
                                    yield $parameter->getPosition() => $parameter;
                                }
                            },
                            'variadic'   => $reffunc->isVariadic(),
                            'nullable'   => [],
                            'positions'  => [],
                            'names'      => [],
                        ];
                        foreach ($parameters as $parameter) {
                            $type = $parameter->getType();
                            $metadata['nullable'][$parameter->getPosition()] = $type ? $type->allowsNull() : null;
                            $metadata['positions'][$parameter->getPosition()] = $parameter->getName();
                            $metadata['names'][$parameter->getName()] = $parameter->getPosition();
                        }
                        return $metadata;
                    })($callback);

                    foreach ($injections as $position => $injection) {
                        // 可変じゃないのに位置引数 or 名前引数が存在しないチェック
                        if (false
                            || is_int($position) && !isset($metadata['positions'][$position]) && !$metadata['variadic']
                            || is_string($position) && !isset($metadata['names'][$position])
                        ) {
                            throw new \InvalidArgumentException("$callback(\$$position) does not exist");
                        }

                        // null セーフモード
                        if ($injection === null && function_configure('chain.nullsafe') && !($metadata['nullable'][$position] ?? false)) {
                            return null;
                        }
                    }

                    // プレースホルダモード
                    if (($placeholder = function_configure('placeholder')) && $placeholders = array_keys($arguments, constant($placeholder), true)) {
                        $arguments = array_replace($arguments, array_fill_keys($placeholders, reset($injections)));
                        $injections = [];
                    }

                    $icount = count($injections);
                    $realargs = [];
                    foreach ($metadata['parameters']() as $pos => $parameter) {
                        $pos -= $icount - count($injections);
                        $nam = $parameter->getName();
                        $variadic = $parameter->isVariadic();

                        if (!$injections && !$arguments) {
                            break;
                        }
                        // inject argument
                        elseif (array_key_exists($i = $pos, $injections) || array_key_exists($i = $nam, $injections)) {
                            $realargs = array_merge($realargs, $variadic && is_array($injections[$i]) ? $injections[$i] : [$injections[$i]]);
                            unset($injections[$i]);
                        }
                        // named or positional argument
                        elseif (array_key_exists($i = $pos, $arguments) || array_key_exists($i = $nam, $arguments)) {
                            $realargs = array_merge($realargs, $variadic && is_array($arguments[$i]) ? $arguments[$i] : [$arguments[$i]]);
                            unset($arguments[$i]);
                        }
                    }
                    return $callback(...$realargs);
                }
            };
        }

        // for compatible
        return new class(...func_get_args()) implements \IteratorAggregate {
            private static $nullables = [];

            private $data;
            private $stack;

            public function __construct($source = null)
            {
                if (func_num_args() === 0) {
                    $this->stack = [];
                }
                $this->data = $source;
            }

            public function __invoke(...$source)
            {
                $func_num_args = func_num_args();

                if ($this->stack !== null && $func_num_args === 0) {
                    throw new \InvalidArgumentException('nonempty stack and no parameter given. maybe invalid __invoke args.');
                }
                if ($this->stack === null && $func_num_args > 0) {
                    throw new \UnexpectedValueException('empty stack and parameter given > 0. maybe invalid __invoke args.');
                }

                if ($func_num_args > 0) {
                    $result = [];
                    foreach ($source as $s) {
                        $chain = chain($s);
                        foreach ($this->stack as $stack) {
                            $chain->{$stack[0]}(...$stack[1]);
                        }
                        $result[] = $chain();
                    }
                    return $func_num_args === 1 ? reset($result) : $result;
                }
                return $this->data;
            }

            public function __get($name)
            {
                return $this->_apply($name, []);
            }

            public function __call($name, $arguments)
            {
                return $this->_apply($name, $arguments);
            }

            public function __toString()
            {
                return (string) $this->data;
            }

            public function getIterator(): \Traversable
            {
                foreach ($this->data as $k => $v) {
                    yield $k => $v;
                }
            }

            public function apply($callback, ...$args)
            {
                if (is_array($this->stack)) {
                    $this->stack[] = [__FUNCTION__, func_get_args()];
                    return $this;
                }

                $this->data = $callback($this->data, ...$args);
                return $this;
            }

            private function _resolve($name)
            {
                $isiterable = is_iterable($this->data);
                $isstringable = is_stringable($this->data);
                if (false
                    // for global
                    || (is_callable($name, false, $fname))
                    || ($isiterable && is_callable("array_$name", false, $fname))
                    || ($isstringable && is_callable("str_$name", false, $fname))
                    // for package
                    || (defined($cname = $name) && is_callable(constant($cname), false, $fname))
                    || ($isiterable && defined($cname = "array_$name") && is_callable(constant($cname), false, $fname))
                    || ($isstringable && defined($cname = "str_$name") && is_callable(constant($cname), false, $fname))
                    // for namespace
                    || (defined($cname = __NAMESPACE__ . "\\$name") && is_callable(constant($cname), false, $fname))
                    || ($isiterable && defined($cname = __NAMESPACE__ . "\\array_$name") && is_callable(constant($cname), false, $fname))
                    || ($isstringable && defined($cname = __NAMESPACE__ . "\\str_$name") && is_callable(constant($cname), false, $fname))
                ) {
                    if (function_configure('chain.nullsafe')) {
                        if (!array_key_exists($fname, self::$nullables)) {
                            foreach (reflect_callable($fname)->getParameters() as $parameter) {
                                $type = $parameter->getType();
                                self::$nullables[$fname][$parameter->getPosition()] = $type ? $type->allowsNull() : null;
                            }
                        }
                    }

                    return $fname;
                }
            }

            private function _apply($name, $arguments)
            {
                if (is_array($this->stack)) {
                    $this->stack[] = [$name, $arguments];
                    return $this;
                }

                // 特別扱い1: map は非常によく呼ぶので引数を補正する
                if ($name === 'map') {
                    return $this->_apply('array_map1', $arguments);
                }

                // 実際の呼び出し1: 存在する関数はそのまま移譲する
                if ($fname = $this->_resolve($name)) {
                    // for nullsafe call
                    if ($this->data === null && !(self::$nullables[$fname][0] ?? true)) {
                        $this->data = null;
                        return $this;
                    }
                    // for placeholder call
                    if (($placeholder = function_configure('placeholder')) && $placeholders = array_keys($arguments, constant($placeholder), true)) {
                        $this->data = $fname(...(array_replace($arguments, array_fill_keys($placeholders, $this->data))));
                        return $this;
                    }
                    // for named call
                    if (is_hasharray($arguments)) {
                        $this->data = $fname(...(array_insert($arguments, [$this->data], next_key($arguments))));
                        return $this; // @codeCoverageIgnore
                    }
                    $this->data = $fname($this->data, ...$arguments);
                    return $this;
                }
                // 実際の呼び出し2: 数値で終わる呼び出しは引数埋め込み位置を指定して移譲する
                if (preg_match('#(.+?)(\d+)$#', $name, $match) && $fname = $this->_resolve($match[1])) {
                    $position = (int) $match[2];
                    if ($this->data === null && !(self::$nullables[$fname][$position] ?? true)) {
                        $this->data = null;
                        return $this;
                    }
                    $this->data = $fname(...array_insert($arguments, [$this->data], $position));
                    return $this;
                }

                // 接尾呼び出し1: E で終わる呼び出しは文字列を eval した callback とする
                if (preg_match('#(.+?)E$#', $name, $match)) {
                    $expr = array_pop($arguments);
                    $expr = strpos($expr, '$_') === false ? '$_ ' . $expr : $expr;
                    $arguments[] = eval_func($expr, '_');
                    return $this->{$match[1]}(...$arguments);
                }
                // 接尾呼び出し2: P で終わる呼び出しは演算子を callback とする
                if (preg_match('#(.+?)P$#', $name, $match)) {
                    $ops = array_reverse((array) array_pop($arguments));
                    $arguments[] = function ($v) use ($ops) {
                        foreach ($ops as $ope => $rand) {
                            if (is_int($ope)) {
                                $ope = $rand;
                                $rand = [];
                            }
                            if (!is_array($rand)) {
                                $rand = [$rand];
                            }
                            $v = ope_func($ope)($v, ...$rand);
                        }
                        return $v;
                    };
                    return $this->{$match[1]}(...$arguments);
                }

                throw new \BadFunctionCallException("$name is not defined.");
            }
        };
    }
}
if (function_exists("ryunosuke\\PHPUnit\\chain") && !defined("ryunosuke\\PHPUnit\\chain")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\chain", "ryunosuke\\PHPUnit\\chain");
}

if (!isset($excluded_functions["throws"]) && (!function_exists("ryunosuke\\PHPUnit\\throws") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\throws"))->isInternal()))) {
    /**
     * throw の関数版
     *
     * hoge() or throw などしたいことがまれによくあるはず。
     *
     * Example:
     * ```php
     * try {
     *     throws(new \Exception('throws'));
     * }
     * catch (\Exception $ex) {
     *     that($ex->getMessage())->isSame('throws');
     * }
     * ```
     *
     * @param \Exception $ex 投げる例外
     * @return mixed （`return hoge or throws` のようなコードで警告が出るので抑止用）
     */
    function throws($ex)
    {
        throw $ex;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\throws") && !defined("ryunosuke\\PHPUnit\\throws")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\throws", "ryunosuke\\PHPUnit\\throws");
}

if (!isset($excluded_functions["function_configure"]) && (!function_exists("ryunosuke\\PHPUnit\\function_configure") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\function_configure"))->isInternal()))) {
    /**
     * 本ライブラリの設定を行う
     *
     * 各関数の挙動を変えたり、デフォルトオプションを設定できる。
     *
     * @param array|string $option 設定。文字列指定時はその値を返す
     * @return array|string 設定値
     */
    function function_configure($option)
    {
        static $config = [];

        // default
        $config['cachedir'] ??= sys_get_temp_dir() . DIRECTORY_SEPARATOR . strtr(__NAMESPACE__, ['\\' => '%']);
        $config['placeholder'] ??= '';
        $config['var_stream'] ??= get_cfg_var('rfunc.var_stream') ?: 'VarStreamV010000';          // for compatible
        $config['memory_stream'] ??= get_cfg_var('rfunc.memory_stream') ?: 'MemoryStreamV010000'; // for compatible
        $config['chain.version'] ??= 1;
        $config['chain.nullsafe'] ??= false;

        // setting
        if (is_array($option)) {
            foreach ($option as $name => $entry) {
                $option[$name] = $config[$name] ?? null;
                switch ($name) {
                    default:
                        $config[$name] = $entry;
                        break;
                    case 'cachedir':
                        $entry ??= $config[$name];
                        if (!file_exists($entry)) {
                            @mkdir($entry, 0777 & (~umask()), true);
                        }
                        $config[$name] = realpath($entry);
                        break;
                    case 'placeholder':
                        if (strlen($entry)) {
                            $entry = ltrim($entry[0] === '\\' ? $entry : __NAMESPACE__ . '\\' . $entry, '\\');
                            if (!defined($entry)) {
                                define($entry, tmpfile() ?: [] ?: '' ?: 0.0 ?: null ?: false);
                            }
                            if (!is_resource(constant($entry))) {
                                // もしリソースじゃないと一意性が保てず致命的になるので例外を投げる
                                throw new \RuntimeException('placeholder is not resource'); // @codeCoverageIgnore
                            }
                            $config[$name] = $entry;
                        }
                        break;
                }
            }
            return $option;
        }

        // getting
        if (is_string($option)) {
            switch ($option) {
                default:
                    return $config[$option] ?? null;
                case 'cachedir':
                    $dirname = $config[$option];
                    if (!file_exists($dirname)) {
                        @mkdir($dirname, 0777 & (~umask()), true); // @codeCoverageIgnore
                    }
                    return realpath($dirname);
            }
        }

        throw new \InvalidArgumentException(sprintf('$option is unknown type(%s)', gettype($option)));
    }
}
if (function_exists("ryunosuke\\PHPUnit\\function_configure") && !defined("ryunosuke\\PHPUnit\\function_configure")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\function_configure", "ryunosuke\\PHPUnit\\function_configure");
}

if (!isset($excluded_functions["cachedir"]) && (!function_exists("ryunosuke\\PHPUnit\\cachedir") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\cachedir"))->isInternal()))) {
    /**
     * 本ライブラリで使用するキャッシュディレクトリを設定する
     *
     * @deprecated use function_configure
     */
    function cachedir($dirname = null)
    {
        return function_configure(['cachedir' => $dirname])['cachedir'];
    }
}
if (function_exists("ryunosuke\\PHPUnit\\cachedir") && !defined("ryunosuke\\PHPUnit\\cachedir")) {
    /**
     * @deprecated
     */
    define("ryunosuke\\PHPUnit\\cachedir", "ryunosuke\\PHPUnit\\cachedir");
}

if (!isset($excluded_functions["cache"]) && (!function_exists("ryunosuke\\PHPUnit\\cache") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\cache"))->isInternal()))) {
    /**
     * シンプルにキャッシュする
     *
     * この関数は get/set/delete を兼ねる。
     * キャッシュがある場合はそれを返し、ない場合は $provider を呼び出してその結果をキャッシュしつつそれを返す。
     *
     * $provider に null を与えるとキャッシュの削除となる。
     *
     * Example:
     * ```php
     * $provider = fn() => rand();
     * // 乱数を返す処理だが、キャッシュされるので同じ値になる
     * $rand1 = cache('rand', $provider);
     * $rand2 = cache('rand', $provider);
     * that($rand1)->isSame($rand2);
     * // $provider に null を与えると削除される
     * cache('rand', null);
     * $rand3 = cache('rand', $provider);
     * that($rand1)->isNotSame($rand3);
     * ```
     *
     * @param string $key キャッシュのキー
     * @param ?callable $provider キャッシュがない場合にコールされる callable
     * @param ?string $namespace 名前空間
     * @return mixed キャッシュ
     */
    function cache($key, $provider, $namespace = null)
    {
        static $cacheobject;
        $cacheobject ??= new class(function_configure('cachedir')) {
            const CACHE_EXT = '.php-cache';

            /** @var string キャッシュディレクトリ */
            private $cachedir;

            /** @var array 内部キャッシュ */
            private $cache;

            /** @var array 変更感知配列 */
            private $changed;

            public function __construct($cachedir)
            {
                $this->cachedir = $cachedir;
                $this->cache = [];
                $this->changed = [];
            }

            public function __destruct()
            {
                // 変更されているもののみ保存
                foreach ($this->changed as $namespace => $dummy) {
                    $filepath = $this->cachedir . '/' . rawurlencode($namespace) . self::CACHE_EXT;
                    $content = "<?php\nreturn " . var_export($this->cache[$namespace], true) . ";\n";

                    $temppath = tempnam(sys_get_temp_dir(), 'cache');
                    if (file_put_contents($temppath, $content) !== false) {
                        @chmod($temppath, 0644);
                        if (!@rename($temppath, $filepath)) {
                            @unlink($temppath); // @codeCoverageIgnore
                        }
                    }
                }
            }

            public function has($namespace, $key)
            {
                // ファイルから読み込む必要があるので get しておく
                $this->get($namespace, $key);
                return array_key_exists($key, $this->cache[$namespace]);
            }

            public function get($namespace, $key)
            {
                // 名前空間自体がないなら作る or 読む
                if (!isset($this->cache[$namespace])) {
                    $nsarray = [];
                    $cachpath = $this->cachedir . '/' . rawurldecode($namespace) . self::CACHE_EXT;
                    if (file_exists($cachpath)) {
                        $nsarray = require $cachpath;
                    }
                    $this->cache[$namespace] = $nsarray;
                }

                return $this->cache[$namespace][$key] ?? null;
            }

            public function set($namespace, $key, $value)
            {
                // 新しい値が来たら変更フラグを立てる
                if (!isset($this->cache[$namespace]) || !array_key_exists($key, $this->cache[$namespace]) || $this->cache[$namespace][$key] !== $value) {
                    $this->changed[$namespace] = true;
                }

                $this->cache[$namespace][$key] = $value;
            }

            public function delete($namespace, $key)
            {
                $this->changed[$namespace] = true;
                unset($this->cache[$namespace][$key]);
            }

            public function clear()
            {
                // インメモリ情報をクリアして・・・
                $this->cache = [];
                $this->changed = [];

                // ファイルも消す
                foreach (glob($this->cachedir . '/*' . self::CACHE_EXT) as $file) {
                    unlink($file);
                }
            }
        };

        // flush (for test)
        if ($key === null) {
            if ($provider === null) {
                $cacheobject->clear();
            }
            $cacheobject = null;
            return;
        }

        $namespace ??= __FILE__;

        $exist = $cacheobject->has($namespace, $key);
        if ($provider === null) {
            $cacheobject->delete($namespace, $key);
            return $exist;
        }
        if (!$exist) {
            $cacheobject->set($namespace, $key, $provider());
        }
        return $cacheobject->get($namespace, $key);
    }
}
if (function_exists("ryunosuke\\PHPUnit\\cache") && !defined("ryunosuke\\PHPUnit\\cache")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\cache", "ryunosuke\\PHPUnit\\cache");
}

if (!isset($excluded_functions["parse_namespace"]) && (!function_exists("ryunosuke\\PHPUnit\\parse_namespace") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\parse_namespace"))->isInternal()))) {
    /**
     * php ファイルをパースして名前空間配列を返す
     *
     * ファイル内で use/use const/use function していたり、シンボルを定義していたりする箇所を検出して名前空間単位で返す。
     *
     * Example:
     * ```php
     * // このような php ファイルをパースすると・・・
     * file_set_contents(sys_get_temp_dir() . '/namespace.php', '
     * <?php
     * namespace NS1;
     * use ArrayObject as AO;
     * use function strlen as SL;
     * function InnerFunc(){}
     * class InnerClass{}
     * define("OUTER\\\\CONST", "OuterConst");
     *
     * namespace NS2;
     * use RuntimeException as RE;
     * use const COUNT_RECURSIVE as CR;
     * class InnerClass{}
     * const InnerConst = 123;
     * ');
     * // このような名前空間配列が得られる
     * that(parse_namespace(sys_get_temp_dir() . '/namespace.php'))->isSame([
     *     'NS1' => [
     *         'const'    => [],
     *         'function' => [
     *             'SL'        => 'strlen',
     *             'InnerFunc' => 'NS1\\InnerFunc',
     *         ],
     *         'alias'    => [
     *             'AO'         => 'ArrayObject',
     *             'InnerClass' => 'NS1\\InnerClass',
     *         ],
     *     ],
     *     'OUTER' => [
     *         'const'    => [
     *             'CONST' => 'OUTER\\CONST',
     *         ],
     *         'function' => [],
     *         'alias'    => [],
     *     ],
     *     'NS2' => [
     *         'const'    => [
     *             'CR'         => 'COUNT_RECURSIVE',
     *             'InnerConst' => 'NS2\\InnerConst',
     *         ],
     *         'function' => [],
     *         'alias'    => [
     *             'RE'         => 'RuntimeException',
     *             'InnerClass' => 'NS2\\InnerClass',
     *         ],
     *     ],
     * ]);
     * ```
     *
     * @param string $filename ファイル名
     * @param array $options オプション配列
     * @return array 名前空間配列
     */
    function parse_namespace($filename, $options = [])
    {
        $filename = realpath($filename);
        $filemtime = filemtime($filename);
        $options += [
            'cache' => null,
        ];
        if ($options['cache'] === null) {
            $options['cache'] = cache($filename, fn() => $filemtime, 'filemtime') >= $filemtime;
        }
        if (!$options['cache']) {
            cache($filename, null, 'filemtime');
            cache($filename, null, __FUNCTION__);
        }
        return cache($filename, function () use ($filename) {
            $stringify = function ($tokens) {
                // @codeCoverageIgnoreStart
                if (version_compare(PHP_VERSION, '8.0.0') >= 0) {
                    return trim(implode('', array_column(array_filter($tokens, function ($token) {
                        /** @noinspection PhpElementIsNotAvailableInCurrentPhpVersionInspection */
                        return in_array($token[0], [T_NAME_QUALIFIED, T_NAME_FULLY_QUALIFIED, T_NAME_RELATIVE, T_STRING], true);
                    }), 1)), '\\');
                }
                // @codeCoverageIgnoreEnd
                return trim(implode('', array_column(array_filter($tokens, function ($token) {
                    return $token[0] === T_NS_SEPARATOR || $token[0] === T_STRING;
                }), 1)), '\\');
            };

            $keys = [
                0           => 'alias', // for use
                T_CLASS     => 'alias',
                T_INTERFACE => 'alias',
                T_TRAIT     => 'alias',
                T_STRING    => 'const', // for define
                T_CONST     => 'const',
                T_FUNCTION  => 'function',
            ];

            $contents = "?>" . file_get_contents($filename);
            $namespace = '';
            $tokens = [-1 => null];
            $result = [];
            while (true) {
                $tokens = parse_php($contents, [
                    'flags'  => TOKEN_PARSE,
                    'begin'  => ["define", T_NAMESPACE, T_USE, T_CONST, T_FUNCTION, T_CLASS, T_INTERFACE, T_TRAIT],
                    'end'    => ['{', ';', '(', T_EXTENDS, T_IMPLEMENTS],
                    'offset' => last_key($tokens) + 1,
                ]);
                if (!$tokens) {
                    break;
                }
                $token = reset($tokens);
                // define は現在の名前空間とは無関係に名前空間定数を宣言することができる
                if ($token[0] === T_STRING && $token[1] === "define") {
                    $tokens = parse_php($contents, [
                        'flags'  => TOKEN_PARSE,
                        'begin'  => [T_CONSTANT_ENCAPSED_STRING],
                        'end'    => [T_CONSTANT_ENCAPSED_STRING],
                        'offset' => last_key($tokens),
                    ]);
                    $cname = substr(implode('', array_column($tokens, 1)), 1, -1);
                    $define = trim(json_decode("\"$cname\""), '\\');
                    [$ns, $nm] = namespace_split($define);
                    if (!isset($result[$ns])) {
                        $result[$ns] = [
                            'const'    => [],
                            'function' => [],
                            'alias'    => [],
                        ];
                    }
                    $result[$ns][$keys[$token[0]]][$nm] = $define;
                }
                switch ($token[0]) {
                    case T_NAMESPACE:
                        $namespace = $stringify($tokens);
                        $result[$namespace] = [
                            'const'    => [],
                            'function' => [],
                            'alias'    => [],
                        ];
                        break;
                    case T_USE:
                        $tokenCorF = array_find($tokens, fn($token) => ($token[0] === T_CONST || $token[0] === T_FUNCTION) ? $token[0] : 0, false);

                        $prefix = '';
                        if (end($tokens)[1] === '{') {
                            $prefix = $stringify($tokens);
                            $tokens = parse_php($contents, [
                                'flags'  => TOKEN_PARSE,
                                'begin'  => ['{'],
                                'end'    => ['}'],
                                'offset' => last_key($tokens),
                            ]);
                        }

                        $multi = array_explode($tokens, fn($token) => $token[1] === ',');
                        foreach ($multi as $ttt) {
                            $as = array_explode($ttt, fn($token) => $token[0] === T_AS);

                            $alias = $stringify($as[0]);
                            if (isset($as[1])) {
                                $result[$namespace][$keys[$tokenCorF]][$stringify($as[1])] = concat($prefix, '\\') . $alias;
                            }
                            else {
                                $result[$namespace][$keys[$tokenCorF]][namespace_split($alias)[1]] = concat($prefix, '\\') . $alias;
                            }
                        }
                        break;
                    case T_CONST:
                    case T_FUNCTION:
                    case T_CLASS:
                    case T_INTERFACE:
                    case T_TRAIT:
                        $alias = $stringify($tokens);
                        if (strlen($alias)) {
                            $result[$namespace][$keys[$token[0]]][$alias] = concat($namespace, '\\') . $alias;
                        }
                        // ブロック内に興味はないので進めておく（function 内 function などはあり得るが考慮しない）
                        if ($token[0] !== T_CONST) {
                            $tokens = parse_php($contents, [
                                'flags'  => TOKEN_PARSE,
                                'begin'  => ['{'],
                                'end'    => ['}'],
                                'offset' => last_key($tokens),
                            ]);
                            break;
                        }
                }
            }
            return $result;
        }, __FUNCTION__);
    }
}
if (function_exists("ryunosuke\\PHPUnit\\parse_namespace") && !defined("ryunosuke\\PHPUnit\\parse_namespace")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\parse_namespace", "ryunosuke\\PHPUnit\\parse_namespace");
}

if (!isset($excluded_functions["resolve_symbol"]) && (!function_exists("ryunosuke\\PHPUnit\\resolve_symbol") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\resolve_symbol"))->isInternal()))) {
    /**
     * エイリアス名を完全修飾名に解決する
     *
     * 例えばあるファイルのある名前空間で `use Hoge\Fuga\Piyo;` してるときの `Piyo` を `Hoge\Fuga\Piyo` に解決する。
     *
     * Example:
     * ```php
     * // このような php ファイルがあるとして・・・
     * file_set_contents(sys_get_temp_dir() . '/symbol.php', '
     * <?php
     * namespace vendor\NS;
     *
     * use ArrayObject as AO;
     * use function strlen as SL;
     *
     * function InnerFunc(){}
     * class InnerClass{}
     * ');
     * // 下記のように解決される
     * that(resolve_symbol('AO', sys_get_temp_dir() . '/symbol.php'))->isSame('ArrayObject');
     * that(resolve_symbol('SL', sys_get_temp_dir() . '/symbol.php'))->isSame('strlen');
     * that(resolve_symbol('InnerFunc', sys_get_temp_dir() . '/symbol.php'))->isSame('vendor\\NS\\InnerFunc');
     * that(resolve_symbol('InnerClass', sys_get_temp_dir() . '/symbol.php'))->isSame('vendor\\NS\\InnerClass');
     * ```
     *
     * @param string $shortname エイリアス名
     * @param string|array $nsfiles ファイル名 or [ファイル名 => 名前空間名]
     * @param array $targets エイリアスタイプ（'const', 'function', 'alias' のいずれか）
     * @return string|null 完全修飾名。解決できなかった場合は null
     */
    function resolve_symbol(string $shortname, $nsfiles, $targets = ['const', 'function', 'alias'])
    {
        // 既に完全修飾されている場合は何もしない
        if (($shortname[0] ?? null) === '\\') {
            return $shortname;
        }

        // use Inner\Space のような名前空間の use の場合を考慮する
        $parts = explode('\\', $shortname, 2);
        $prefix = isset($parts[1]) ? array_shift($parts) : null;

        if (is_string($nsfiles)) {
            $nsfiles = [$nsfiles => []];
        }

        $targets = (array) $targets;
        foreach ($nsfiles as $filename => $namespaces) {
            $namespaces = array_flip(array_map(fn($n) => trim($n, '\\'), (array) $namespaces));
            foreach (parse_namespace($filename) as $namespace => $ns) {
                /** @noinspection PhpIllegalArrayKeyTypeInspection */
                if (!$namespaces || isset($namespaces[$namespace])) {
                    if (isset($ns['alias'][$prefix])) {
                        return $ns['alias'][$prefix] . '\\' . implode('\\', $parts);
                    }
                    foreach ($targets as $target) {
                        if (isset($ns[$target][$shortname])) {
                            return $ns[$target][$shortname];
                        }
                    }
                }
            }
        }
        return null;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\resolve_symbol") && !defined("ryunosuke\\PHPUnit\\resolve_symbol")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\resolve_symbol", "ryunosuke\\PHPUnit\\resolve_symbol");
}

if (!isset($excluded_functions["is_ansi"]) && (!function_exists("ryunosuke\\PHPUnit\\is_ansi") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\is_ansi"))->isInternal()))) {
    /**
     * リソースが ansi color に対応しているか返す
     *
     * パイプしたりリダイレクトしていると false を返す。
     *
     * @see https://github.com/symfony/console/blob/v4.2.8/Output/StreamOutput.php#L98
     *
     * @param resource $stream 調べるリソース
     * @return bool ansi color に対応しているなら true
     */
    function is_ansi($stream)
    {
        // テスト用に隠し引数で DS を取っておく
        $DIRECTORY_SEPARATOR = DIRECTORY_SEPARATOR;
        assert(!!$DIRECTORY_SEPARATOR = func_num_args() > 1 ? func_get_arg(1) : $DIRECTORY_SEPARATOR);

        if ('Hyper' === getenv('TERM_PROGRAM')) {
            return true;
        }

        if ($DIRECTORY_SEPARATOR === '\\') {
            return (\function_exists('sapi_windows_vt100_support') && @sapi_windows_vt100_support($stream))
                || false !== getenv('ANSICON')
                || 'ON' === getenv('ConEmuANSI')
                || 'xterm' === getenv('TERM');
        }

        return @stream_isatty($stream);
    }
}
if (function_exists("ryunosuke\\PHPUnit\\is_ansi") && !defined("ryunosuke\\PHPUnit\\is_ansi")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\is_ansi", "ryunosuke\\PHPUnit\\is_ansi");
}

if (!isset($excluded_functions["ansi_colorize"]) && (!function_exists("ryunosuke\\PHPUnit\\ansi_colorize") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\ansi_colorize"))->isInternal()))) {
    /**
     * 文字列に ANSI Color エスケープシーケンスを埋め込む
     *
     * - "blue" のような小文字色名は文字色
     * - "BLUE" のような大文字色名は背景色
     * - "bold" のようなスタイル名は装飾
     *
     * となる。その区切り文字は現在のところ厳密に定めていない（`fore+back|bold` のような形式で定めることも考えたけどメリットがない）。
     * つまり、アルファベット以外で分割するので、
     *
     * - `blue|WHITE@bold`: 文字青・背景白・太字
     * - `blue WHITE bold underscore`: 文字青・背景白・太字・下線
     * - `italic|bold,blue+WHITE  `: 文字青・背景白・太字・斜体
     *
     * という動作になる（記号で区切られていれば形式はどうでも良いということ）。
     * ただ、この指定方法は変更が入る可能性が高いのでスペースあたりで区切っておくのがもっとも無難。
     *
     * @param string $string 対象文字列
     * @param string $color 色とスタイル文字列
     * @return string エスケープシーケンス付きの文字列
     */
    function ansi_colorize($string, $color)
    {
        // see https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_parameters
        // see https://misc.flogisoft.com/bash/tip_colors_and_formatting
        $ansicodes = [
            // forecolor
            'default'    => [39, 39],
            'black'      => [30, 39],
            'red'        => [31, 39],
            'green'      => [32, 39],
            'yellow'     => [33, 39],
            'blue'       => [34, 39],
            'magenta'    => [35, 39],
            'cyan'       => [36, 39],
            'white'      => [97, 39],
            'gray'       => [90, 39],
            // backcolor
            'DEFAULT'    => [49, 49],
            'BLACK'      => [40, 49],
            'RED'        => [41, 49],
            'GREEN'      => [42, 49],
            'YELLOW'     => [43, 49],
            'BLUE'       => [44, 49],
            'MAGENTA'    => [45, 49],
            'CYAN'       => [46, 49],
            'WHITE'      => [47, 49],
            'GRAY'       => [100, 49],
            // style
            'bold'       => [1, 22],
            'faint'      => [2, 22], // not working ?
            'italic'     => [3, 23],
            'underscore' => [4, 24],
            'blink'      => [5, 25],
            'reverse'    => [7, 27],
            'conceal'    => [8, 28],
        ];

        $names = array_flip(preg_split('#[^a-z]#i', $color));
        $styles = array_intersect_key($ansicodes, $names);
        $setters = implode(';', array_column($styles, 0));
        $unsetters = implode(';', array_column($styles, 1));
        return "\033[{$setters}m{$string}\033[{$unsetters}m";
    }
}
if (function_exists("ryunosuke\\PHPUnit\\ansi_colorize") && !defined("ryunosuke\\PHPUnit\\ansi_colorize")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\ansi_colorize", "ryunosuke\\PHPUnit\\ansi_colorize");
}

if (!isset($excluded_functions["process_async"]) && (!function_exists("ryunosuke\\PHPUnit\\process_async") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\process_async"))->isInternal()))) {
    /**
     * proc_open ～ proc_close の一連の処理を行う（非同期版）
     *
     * @see process()
     *
     * @param string $command 実行コマンド
     * @param array|string $args コマンドライン引数。文字列はそのまま結合され、配列は escapeshellarg された上でキーと結合される
     * @param string|resource $stdin 標準入力（string を渡すと単純に読み取れられる。resource を渡すと fread される）
     * @param string|resource $stdout 標準出力（string を渡すと参照渡しで格納される。resource を渡すと fwrite される）
     * @param string|resource $stderr 標準エラー（string を渡すと参照渡しで格納される。resource を渡すと fwrite される）
     * @param ?string $cwd 作業ディレクトリ
     * @param ?array $env 環境変数
     * @return \ProcessAsync|object プロセスオブジェクト
     */
    function process_async($command, $args = [], $stdin = '', &$stdout = '', &$stderr = '', $cwd = null, array $env = null)
    {
        if (is_array($args)) {
            $statement = [$command];
            foreach ($args as $k => $v) {
                if (!is_int($k)) {
                    $statement[] = $k;
                }
                $statement[] = $v;
            }
        }
        else {
            $statement = escapeshellcmd($command) . " $args";
        }

        $proc = proc_open($statement, [
            0 => is_resource($stdin) ? $stdin : ['pipe', 'r'],
            1 => ['pipe', 'w'],
            2 => ['pipe', 'w'],
        ], $pipes, $cwd, $env);

        if ($proc === false) {
            // どうしたら失敗するのかわからない
            throw new \RuntimeException("$command start failed."); // @codeCoverageIgnore
        }

        if (!is_resource($stdin)) {
            fwrite($pipes[0], $stdin);
            fclose($pipes[0]);
        }
        if (!is_resource($stdout)) {
            $stdout = '';
        }
        if (!is_resource($stderr)) {
            $stderr = '';
        }

        stream_set_blocking($pipes[1], false);
        stream_set_blocking($pipes[2], false);
        stream_set_read_buffer($pipes[1], 4096);
        stream_set_read_buffer($pipes[2], 4096);

        return new class($proc, $pipes, $stdout, $stderr) {
            private $proc;
            private $pipes;
            private $status;
            public  $stdout;
            public  $stderr;

            public function __construct($proc, $pipes, &$stdout, &$stderr)
            {
                $this->proc = $proc;
                $this->pipes = $pipes;
                $this->stdout = &$stdout;
                $this->stderr = &$stderr;
            }

            public function __destruct()
            {
                if ($this->proc !== null) {
                    fclose($this->pipes[1]);
                    fclose($this->pipes[2]);
                    proc_close($this->proc);
                }
            }

            public function __invoke()
            {
                try {
                    /** @noinspection PhpStatementHasEmptyBodyInspection */
                    while ($this->update()) {
                        // noop
                    }
                }
                finally {
                    $this->status = proc_get_status($this->proc);
                    fclose($this->pipes[1]);
                    fclose($this->pipes[2]);
                    $rc = proc_close($this->proc);
                    $this->proc = null;
                }

                return $this->status['running'] ? $rc : $this->status['exitcode'];
            }

            public function update()
            {
                if ($this->proc === null || (feof($this->pipes[1]) && feof($this->pipes[2]))) {
                    return false;
                }

                $read = [$this->pipes[1], $this->pipes[2]];
                $write = $except = null;
                if (stream_select($read, $write, $except, 1) === false) {
                    // （システムコールが別のシグナルによって中断された場合などに起こりえます）
                    throw new \RuntimeException('stream_select failed.'); // @codeCoverageIgnore
                }
                foreach ($read as $fp) {
                    $buffer = fread($fp, 1024);
                    if ($fp === $this->pipes[1]) {
                        if (!is_resource($this->stdout)) {
                            $this->stdout .= $buffer;
                        }
                        else {
                            fwrite($this->stdout, $buffer);
                        }
                    }
                    elseif ($fp === $this->pipes[2]) {
                        if (!is_resource($this->stderr)) {
                            $this->stderr .= $buffer;
                        }
                        else {
                            fwrite($this->stderr, $buffer);
                        }
                    }
                }
                return true;
            }

            public function status()
            {
                $this->update();
                return $this->status ?? proc_get_status($this->proc);
            }

            public function terminate()
            {
                fclose($this->pipes[1]);
                fclose($this->pipes[2]);
                proc_terminate($this->proc);
                // terminate はシグナルを送るだけなので終了を待つ（さらに SIGTERM なので終わらないかもしれないので1秒ほどで打ち切る）
                for ($i = 0; $i < 100; $i++, usleep(10_000)) {
                    $this->status = proc_get_status($this->proc);
                    if (!$this->status['running']) {
                        break;
                    }
                }
                $this->proc = null;
                return !$this->status['running'];
            }
        };
    }
}
if (function_exists("ryunosuke\\PHPUnit\\process_async") && !defined("ryunosuke\\PHPUnit\\process_async")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\process_async", "ryunosuke\\PHPUnit\\process_async");
}

if (!isset($excluded_functions["arguments"]) && (!function_exists("ryunosuke\\PHPUnit\\arguments") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\arguments"))->isInternal()))) {
    /**
     * コマンドライン引数をパースして引数とオプションを返す
     *
     * 少しリッチな {@link http://php.net/manual/function.getopt.php getopt} として使える（shell 由来のオプション構文(a:b::)はどうも馴染みにくい）。
     * ただし「値が必須なオプション」はサポートしない。
     * もっとも、オプションとして空文字が来ることはほぼ無いのでデフォルト値を空文字にすることで対応可能。
     *
     * $rule に従って `--noval filename --opt optval` のような文字列・配列をパースする。
     * $rule 配列の仕様は下記。
     *
     * - キーは「オプション名」を指定する。ただし・・・
     *     - 数値キーは「引数」を意味する
     *     - スペースの後に「ショート名」を与えられる
     * - 値は「デフォルト値」を指定する。ただし・・・
     *     - `[]` は「複数値オプション」を意味する（配列にしない限り同オプションの多重指定は許されない）
     *     - `null` は「値なしオプション」を意味する（スイッチングオプション）
     * - 空文字キーは解釈自体のオプションを与える
     *     - 今のところ throw のみの実装。配列ではなく bool を与えられる
     *
     * 上記の仕様でパースして「引数は数値連番、オプションはオプション名をキーとした配列」を返す。
     * なお、いわゆる「引数」はどこに来ても良い（前オプション、後オプションの区別がない）。
     *
     * $argv には配列や文字列が与えられるが、ほとんどテスト用に近く、普通は未指定で $argv を使うはず。
     *
     * Example:
     * ```php
     * // いくつか織り交ぜたスタンダードな例
     * $rule = [
     *     'opt'       => 'def',    // 基本的には「デフォルト値」を表す
     *     'longopt l' => '',       // スペース区切りで「ショート名」を意味する
     *     1           => 'defarg', // 数値キーは「引数」を意味する
     * ];
     * that(arguments($rule, '--opt optval arg1 -l longval'))->isSame([
     *     'opt'     => 'optval',  // optval と指定している
     *     'longopt' => 'longval', // ショート名指定でも本来の名前で返ってくる
     *     'arg1',   // いわゆるコマンドライン引数（optval は opt に飲まれるので含まれない）
     *     'defarg', // いわゆるコマンドライン引数（与えられていないが、ルールの 1 => 'defarg' が活きている）
     * ]);
     *
     * // 「値なしオプション」と「複数値オプション」の例
     * $rule = [
     *     'noval1 l'  => null, // null は「値なしオプション」を意味する（指定されていれば true されていなければ false を返す）
     *     'noval2 m'  => null, // 同上
     *     'noval3 n'  => null, // 同上
     *     'opts o' => [],      // 配列を与えると「複数値オプション」を表す
     * ];
     * that(arguments($rule, '--opts o1 -ln arg1 -o o2 arg2 --opts o3'))->isSame([
     *     'noval1' => true,  // -ln で同時指定されているので true
     *     'noval2' => false, // -ln で同時指定されてないので false
     *     'noval3' => true,  // -ln の同時指定されているので true
     *     'opts'   => ['o1', 'o2', 'o3'], // ロング、ショート混在でも OK
     *     'arg1', // 一見 -ln のオプション値に見えるが、 noval は値なしなので引数として得られる
     *     'arg2', // 前オプション、後オプションの区別はないのでどこに居ようと引数として得られる
     * ]);
     *
     * // 空文字で解釈自体のオプションを与える
     * $rule = [
     *     ''  => false, // 定義されていないオプションが来ても例外を投げずに引数として処理する
     * ];
     * that(arguments($rule, '--long A -short B'))->isSame([
     *     '--long', // 明らかにオプション指定に見えるが、 long というオプションは定義されていないので引数として解釈される
     *     'A',      // 同上。long のオプション値に見えるが、ただの引数
     *     '-short', // 同上。short というオプションは定義されていない
     *     'B',      // 同上。short のオプション値に見えるが、ただの引数
     * ]);
     * ```
     *
     * @param array $rule オプションルール
     * @param array|string|null $argv パースするコマンドライン引数。未指定時は $argv が使用される
     * @return array コマンドライン引数＋オプション
     */
    function arguments($rule, $argv = null)
    {
        $opt = array_unset($rule, '', []);
        if (is_bool($opt)) {
            $opt = ['thrown' => $opt];
        }
        $opt += [
            'thrown' => true,
        ];

        if ($argv === null) {
            $argv = array_slice($_SERVER['argv'], 1); // @codeCoverageIgnore
        }
        if (is_string($argv)) {
            $argv = quoteexplode([" ", "\t"], $argv);
            $argv = array_filter($argv, 'strlen');
        }
        $argv = array_values($argv);

        $shortmap = [];
        $argsdefaults = [];
        $optsdefaults = [];
        foreach ($rule as $name => $default) {
            if (is_int($name)) {
                $argsdefaults[$name] = $default;
                continue;
            }
            [$longname, $shortname] = preg_split('#\s+#u', $name, -1, PREG_SPLIT_NO_EMPTY) + [1 => ''];
            if (strlen($shortname)) {
                if (array_key_exists($shortname, $shortmap)) {
                    throw new \InvalidArgumentException("duplicated short option name '$shortname'");
                }
                $shortmap[$shortname] = $longname;
            }
            if (array_key_exists($longname, $optsdefaults)) {
                throw new \InvalidArgumentException("duplicated option name '$shortname'");
            }
            $optsdefaults[$longname] = $default;
        }

        $n = 0;
        $already = [];
        $result = array_map(fn($v) => $v === null ? false : $v, $optsdefaults);
        while (($token = array_shift($argv)) !== null) {
            if (strlen($token) >= 2 && $token[0] === '-') {
                if ($token[1] === '-') {
                    $optname = substr($token, 2);
                    if (!$opt['thrown'] && !array_key_exists($optname, $optsdefaults)) {
                        $result[$n++] = $token;
                        continue;
                    }
                }
                else {
                    $shortname = substr($token, 1);
                    if (!$opt['thrown'] && !array_keys_exist(str_split($shortname, 1), $shortmap)) {
                        $result[$n++] = $token;
                        continue;
                    }
                    if (strlen($shortname) > 1) {
                        array_unshift($argv, '-' . substr($shortname, 1));
                        $shortname = substr($shortname, 0, 1);
                    }
                    if (!isset($shortmap[$shortname])) {
                        throw new \InvalidArgumentException("undefined short option name '$shortname'.");
                    }
                    $optname = $shortmap[$shortname];
                }

                if (!array_key_exists($optname, $optsdefaults)) {
                    throw new \InvalidArgumentException("undefined option name '$optname'.");
                }
                if (isset($already[$optname]) && !is_array($result[$optname])) {
                    throw new \InvalidArgumentException("'$optname' is specified already.");
                }
                $already[$optname] = true;

                if ($optsdefaults[$optname] === null) {
                    $result[$optname] = true;
                }
                else {
                    if (!isset($argv[0]) || strpos($argv[0], '-') === 0) {
                        throw new \InvalidArgumentException("'$optname' requires value.");
                    }
                    if (is_array($result[$optname])) {
                        $result[$optname][] = array_shift($argv);
                    }
                    else {
                        $result[$optname] = array_shift($argv);
                    }
                }
            }
            else {
                $result[$n++] = $token;
            }
        }

        array_walk_recursive($result, function (&$v) {
            if (is_string($v)) {
                $v = trim(str_replace('\\"', '"', $v), '"');
            }
        });
        return $result + $argsdefaults;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\arguments") && !defined("ryunosuke\\PHPUnit\\arguments")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\arguments", "ryunosuke\\PHPUnit\\arguments");
}

if (!isset($excluded_functions["stacktrace"]) && (!function_exists("ryunosuke\\PHPUnit\\stacktrace") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\stacktrace"))->isInternal()))) {
    /**
     * スタックトレースを文字列で返す
     *
     * `(new \Exception())->getTraceAsString()` と実質的な役割は同じ。
     * ただし、 getTraceAsString は引数が Array になったりクラス名しか取れなかったり微妙に使い勝手が悪いのでもうちょっと情報量を増やしたもの。
     *
     * 第1引数 $traces はトレース的配列を受け取る（`(new \Exception())->getTrace()` とか）。
     * 未指定時は debug_backtrace() で採取する。
     *
     * 第2引数 $option は文字列化する際の設定を指定する。
     * 情報量が増える分、機密も含まれる可能性があるため、 mask オプションで塗りつぶすキーや引数名を指定できる（クロージャの引数までは手出ししないため留意）。
     * limit と format は比較的指定頻度が高いかつ互換性維持のため配列オプションではなく直に渡すことが可能になっている。
     *
     * @param ?array $traces debug_backtrace 的な配列
     * @param int|string|array $option オプション
     * @return string|array トレース文字列（delimiter オプションに null を渡すと配列で返す）
     */
    function stacktrace($traces = null, $option = [])
    {
        if (is_int($option)) {
            $option = ['limit' => $option];
        }
        elseif (is_string($option)) {
            $option = ['format' => $option];
        }

        $option += [
            'format'    => '%s:%s %s', // 文字列化するときの sprintf フォーマット
            'args'      => true,       // 引数情報を埋め込むか否か
            'limit'     => 16,         // 配列や文字列を千切る長さ
            'delimiter' => "\n",       // スタックトレースの区切り文字（null で配列になる）
            'mask'      => ['#^password#', '#^secret#', '#^credential#', '#^credit#'],
        ];
        $limit = $option['limit'];
        $maskregexs = (array) $option['mask'];
        $mask = static function ($key, $value) use ($maskregexs) {
            if (!is_string($value)) {
                return $value;
            }
            foreach ($maskregexs as $regex) {
                if (preg_match($regex, $key)) {
                    return str_repeat('*', strlen($value));
                }
            }
            return $value;
        };

        $stringify = static function ($value) use ($limit, $mask) {
            // 再帰用クロージャ
            $export = static function ($value, $nest = 0, $parents = []) use (&$export, $limit, $mask) {
                // 再帰を検出したら *RECURSION* とする（処理に関しては is_recursive のコメント参照）
                foreach ($parents as $parent) {
                    if ($parent === $value) {
                        return var_export('*RECURSION*', true);
                    }
                }
                // 配列は連想判定したり再帰したり色々
                if (is_array($value)) {
                    $parents[] = $value;
                    $flat = $value === array_values($value);
                    $kvl = [];
                    foreach ($value as $k => $v) {
                        if (count($kvl) >= $limit) {
                            $kvl[] = sprintf('...(more %d length)', count($value) - $limit);
                            break;
                        }
                        $kvl[] = ($flat ? '' : $k . ':') . $export(call_user_func($mask, $k, $v), $nest + 1, $parents);
                    }
                    return ($flat ? '[' : '{') . implode(', ', $kvl) . ($flat ? ']' : '}');
                }
                // オブジェクトは単にプロパティを配列的に出力する
                elseif (is_object($value)) {
                    $parents[] = $value;
                    return get_class($value) . $export(get_object_properties($value), $nest, $parents);
                }
                // 文字列は改行削除
                elseif (is_string($value)) {
                    $value = str_replace(["\r\n", "\r", "\n"], '\n', $value);
                    if (($strlen = strlen($value)) > $limit) {
                        $value = substr($value, 0, $limit) . sprintf('...(more %d length)', $strlen - $limit);
                    }
                    return '"' . addcslashes($value, "\"\0\\") . '"';
                }
                // それ以外は stringify
                else {
                    return stringify($value);
                }
            };

            return $export($value);
        };

        $traces ??= array_slice(debug_backtrace(), 1);
        $result = [];
        foreach ($traces as $i => $trace) {
            // メソッド内で関数定義して呼び出したりすると file が無いことがある（かなりレアケースなので無視する）
            if (!isset($trace['file'])) {
                continue; // @codeCoverageIgnore
            }

            $file = $trace['file'];
            $line = $trace['line'];
            if (strpos($trace['file'], "eval()'d code") !== false && ($traces[$i + 1]['function'] ?? '') === 'eval') {
                $file = $traces[$i + 1]['file'];
                $line = $traces[$i + 1]['line'] . "." . $trace['line'];
            }

            if (isset($trace['type'])) {
                $callee = $trace['class'] . $trace['type'] . $trace['function'];
                if ($option['args'] && $maskregexs && method_exists($trace['class'], $trace['function'])) {
                    $ref = new \ReflectionMethod($trace['class'], $trace['function']);
                }
            }
            else {
                $callee = $trace['function'];
                if ($option['args'] && $maskregexs && function_exists($callee)) {
                    $ref = new \ReflectionFunction($trace['function']);
                }
            }
            $args = [];
            if ($option['args']) {
                $args = $trace['args'] ?? [];
                if (isset($ref)) {
                    $params = $ref->getParameters();
                    foreach ($params as $n => $param) {
                        if (array_key_exists($n, $args)) {
                            $args[$n] = $mask($param->getName(), $args[$n]);
                        }
                    }
                }
            }
            $callee .= '(' . implode(', ', array_map($stringify, $args)) . ')';

            $result[] = sprintf($option['format'], $file, $line, $callee);
        }
        if ($option['delimiter'] === null) {
            return $result;
        }
        return implode($option['delimiter'], $result);
    }
}
if (function_exists("ryunosuke\\PHPUnit\\stacktrace") && !defined("ryunosuke\\PHPUnit\\stacktrace")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\stacktrace", "ryunosuke\\PHPUnit\\stacktrace");
}

if (!isset($excluded_functions["stringify"]) && (!function_exists("ryunosuke\\PHPUnit\\stringify") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\stringify"))->isInternal()))) {
    /**
     * 値を何とかして文字列化する
     *
     * この関数の出力は互換性を考慮しない。頻繁に変更される可能性がある。
     *
     * @param mixed $var 文字列化する値
     * @return string $var を文字列化したもの
     */
    function stringify($var)
    {
        $type = gettype($var);
        switch ($type) {
            case 'NULL':
                return 'null';
            case 'boolean':
                return $var ? 'true' : 'false';
            case 'array':
                return var_export2($var, true);
            case 'object':
                if (method_exists($var, '__toString')) {
                    return (string) $var;
                }
                if (method_exists($var, '__serialize') || $var instanceof \Serializable) {
                    return serialize($var);
                }
                if ($var instanceof \JsonSerializable) {
                    return get_class($var) . ':' . json_encode($var, JSON_UNESCAPED_UNICODE);
                }
                return get_class($var);

            default:
                return (string) $var;
        }
    }
}
if (function_exists("ryunosuke\\PHPUnit\\stringify") && !defined("ryunosuke\\PHPUnit\\stringify")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\stringify", "ryunosuke\\PHPUnit\\stringify");
}

if (!isset($excluded_functions["numval"]) && (!function_exists("ryunosuke\\PHPUnit\\numval") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\numval"))->isInternal()))) {
    /**
     * 値を数値化する
     *
     * int か float ならそのまま返す。
     * 文字列の場合、一言で言えば「.を含むなら float、含まないなら int」を返す。
     * int でも float でも stringable でもない場合は実装依存（ただの int キャスト）。
     *
     * Example:
     * ```php
     * that(numval(3.14))->isSame(3.14);   // int や float はそのまま返す
     * that(numval('3.14'))->isSame(3.14); // . を含む文字列は float を返す
     * that(numval('11', 8))->isSame(9);   // 基数が指定できる
     * ```
     *
     * @param mixed $var 数値化する値
     * @param int $base 基数。int 的な値のときしか意味をなさない
     * @return int|float 数値化した値
     */
    function numval($var, $base = 10)
    {
        if (is_int($var) || is_float($var)) {
            return $var;
        }
        if (is_object($var)) {
            $var = (string) $var;
        }
        if (is_string($var) && strpos($var, '.') !== false) {
            return (float) $var;
        }
        return intval($var, $base);
    }
}
if (function_exists("ryunosuke\\PHPUnit\\numval") && !defined("ryunosuke\\PHPUnit\\numval")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\numval", "ryunosuke\\PHPUnit\\numval");
}

if (!isset($excluded_functions["arrayval"]) && (!function_exists("ryunosuke\\PHPUnit\\arrayval") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\arrayval"))->isInternal()))) {
    /**
     * array キャストの関数版
     *
     * intval とか strval とかの array 版。
     * ただキャストするだけだが、関数なのでコールバックとして使える。
     *
     * $recursive を true にすると再帰的に適用する（デフォルト）。
     * 入れ子オブジェクトを配列化するときなどに使える。
     *
     * Example:
     * ```php
     * // キャストなので基本的には配列化される
     * that(arrayval(123))->isSame([123]);
     * that(arrayval('str'))->isSame(['str']);
     * that(arrayval([123]))->isSame([123]); // 配列は配列のまま
     *
     * // $recursive = false にしない限り再帰的に適用される
     * $stdclass = stdclass(['key' => 'val']);
     * that(arrayval([$stdclass], true))->isSame([['key' => 'val']]); // true なので中身も配列化される
     * that(arrayval([$stdclass], false))->isSame([$stdclass]);       // false なので中身は変わらない
     * ```
     *
     * @param mixed $var array 化する値
     * @param bool $recursive 再帰的に行うなら true
     * @return array array 化した配列
     */
    function arrayval($var, $recursive = true)
    {
        // return json_decode(json_encode($var), true);

        // 無駄なループを回したくないので非再帰で配列の場合はそのまま返す
        if (!$recursive && is_array($var)) {
            return $var;
        }

        if (is_primitive($var)) {
            return (array) $var;
        }

        $result = [];
        foreach ($var as $k => $v) {
            if ($recursive && !is_primitive($v)) {
                $v = arrayval($v, $recursive);
            }
            $result[$k] = $v;
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\arrayval") && !defined("ryunosuke\\PHPUnit\\arrayval")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\arrayval", "ryunosuke\\PHPUnit\\arrayval");
}

if (!isset($excluded_functions["si_unprefix"]) && (!function_exists("ryunosuke\\PHPUnit\\si_unprefix") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\si_unprefix"))->isInternal()))) {
    /**
     * SI 接頭辞が付与された文字列を数値化する
     *
     * 典型的な用途は ini_get で得られた値を数値化したいとき。
     * ただし、 ini は 1m のように小文字で指定することもあるので大文字化する必要はある。
     *
     * Example:
     * ```php
     * // 1k = 1000
     * that(si_unprefix('1k'))->isSame(1000);
     * // 1k = 1024
     * that(si_unprefix('1k', 1024))->isSame(1024);
     * // m はメガではなくミリ
     * that(si_unprefix('1m'))->isSame(0.001);
     * // M がメガ
     * that(si_unprefix('1M'))->isSame(1000000);
     * // K だけは特別扱いで大文字小文字のどちらでもキロになる
     * that(si_unprefix('1K'))->isSame(1000);
     * ```
     *
     * @param mixed $var 数値化する値
     * @param int $unit 桁単位。実用上は 1000, 1024 の2値しか指定することはないはず
     * @return int|float SI 接頭辞を取り払った実際の数値
     */
    function si_unprefix($var, $unit = 1000)
    {
        assert($unit > 0);

        $var = trim($var);

        foreach (SI_UNITS as $exp => $sis) {
            foreach ($sis as $si) {
                if (strpos($var, $si) === (strlen($var) - strlen($si))) {
                    return numval($var) * pow($unit, $exp);
                }
            }
        }

        return numval($var);
    }
}
if (function_exists("ryunosuke\\PHPUnit\\si_unprefix") && !defined("ryunosuke\\PHPUnit\\si_unprefix")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\si_unprefix", "ryunosuke\\PHPUnit\\si_unprefix");
}

if (!isset($excluded_functions["is_empty"]) && (!function_exists("ryunosuke\\PHPUnit\\is_empty") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\is_empty"))->isInternal()))) {
    /**
     * 値が空か検査する
     *
     * `empty` とほぼ同じ。ただし
     *
     * - string: "0"
     * - countable でない object
     * - countable である object で count() > 0
     *
     * は false 判定する。
     * ただし、 $empty_stcClass に true を指定すると「フィールドのない stdClass」も true を返すようになる。
     * これは stdClass の立ち位置はかなり特殊で「フィールドアクセスできる組み込み配列」のような扱いをされることが多いため。
     * （例えば `json_decode('{}')` は stdClass を返すが、このような状況は空判定したいことが多いだろう）。
     *
     * なお、関数の仕様上、未定義変数を true 判定することはできない。
     * 未定義変数をチェックしたい状況は大抵の場合コードが悪いが `$array['key1']['key2']` を調べたいことはある。
     * そういう時には使えない（?? する必要がある）。
     *
     * 「 `if ($var) {}` で十分なんだけど "0" が…」という状況はまれによくあるはず。
     *
     * Example:
     * ```php
     * // この辺は empty と全く同じ
     * that(is_empty(null))->isTrue();
     * that(is_empty(false))->isTrue();
     * that(is_empty(0))->isTrue();
     * that(is_empty(''))->isTrue();
     * // この辺だけが異なる
     * that(is_empty('0'))->isFalse();
     * // 第2引数に true を渡すと空の stdClass も empty 判定される
     * $stdclass = new \stdClass();
     * that(is_empty($stdclass, true))->isTrue();
     * // フィールドがあれば empty ではない
     * $stdclass->hoge = 123;
     * that(is_empty($stdclass, true))->isFalse();
     * ```
     *
     * @param mixed $var 判定する値
     * @param bool $empty_stdClass 空の stdClass を空とみなすか
     * @return bool 空なら true
     */
    function is_empty($var, $empty_stdClass = false)
    {
        // object は is_countable 次第
        if (is_object($var)) {
            // が、 stdClass だけは特別扱い（stdClass は継承もできるので、クラス名で判定する（継承していたらそれはもう stdClass ではないと思う））
            if ($empty_stdClass && get_class($var) === 'stdClass') {
                return !(array) $var;
            }
            if (is_countable($var)) {
                return !count($var);
            }
            return false;
        }

        // "0" は false
        if ($var === '0') {
            return false;
        }

        // 上記以外は empty に任せる
        return empty($var);
    }
}
if (function_exists("ryunosuke\\PHPUnit\\is_empty") && !defined("ryunosuke\\PHPUnit\\is_empty")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\is_empty", "ryunosuke\\PHPUnit\\is_empty");
}

if (!isset($excluded_functions["is_primitive"]) && (!function_exists("ryunosuke\\PHPUnit\\is_primitive") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\is_primitive"))->isInternal()))) {
    /**
     * 値が複合型でないか検査する
     *
     * 「複合型」とはオブジェクトと配列のこと。
     * つまり
     *
     * - is_scalar($var) || is_null($var) || is_resource($var)
     *
     * と同義（!is_array($var) && !is_object($var) とも言える）。
     *
     * Example:
     * ```php
     * that(is_primitive(null))->isTrue();
     * that(is_primitive(false))->isTrue();
     * that(is_primitive(123))->isTrue();
     * that(is_primitive(STDIN))->isTrue();
     * that(is_primitive(new \stdClass))->isFalse();
     * that(is_primitive(['array']))->isFalse();
     * ```
     *
     * @param mixed $var 調べる値
     * @return bool 複合型なら false
     */
    function is_primitive($var)
    {
        return is_scalar($var) || is_null($var) || is_resource($var);
    }
}
if (function_exists("ryunosuke\\PHPUnit\\is_primitive") && !defined("ryunosuke\\PHPUnit\\is_primitive")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\is_primitive", "ryunosuke\\PHPUnit\\is_primitive");
}

if (!isset($excluded_functions["is_stringable"]) && (!function_exists("ryunosuke\\PHPUnit\\is_stringable") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\is_stringable"))->isInternal()))) {
    /**
     * 変数が文字列化できるか調べる
     *
     * 「配列」「__toString を持たないオブジェクト」が false になる。
     * （厳密に言えば配列は "Array" になるので文字列化できるといえるがここでは考えない）。
     *
     * Example:
     * ```php
     * // こいつらは true
     * that(is_stringable(null))->isTrue();
     * that(is_stringable(true))->isTrue();
     * that(is_stringable(3.14))->isTrue();
     * that(is_stringable(STDOUT))->isTrue();
     * that(is_stringable(new \Exception()))->isTrue();
     * // こいつらは false
     * that(is_stringable(new \ArrayObject()))->isFalse();
     * that(is_stringable([1, 2, 3]))->isFalse();
     * ```
     *
     * @param mixed $var 調べる値
     * @return bool 文字列化できるなら true
     */
    function is_stringable($var)
    {
        if (is_array($var)) {
            return false;
        }
        if (is_object($var) && !method_exists($var, '__toString')) {
            return false;
        }
        return true;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\is_stringable") && !defined("ryunosuke\\PHPUnit\\is_stringable")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\is_stringable", "ryunosuke\\PHPUnit\\is_stringable");
}

if (!isset($excluded_functions["var_hash"]) && (!function_exists("ryunosuke\\PHPUnit\\var_hash") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\var_hash"))->isInternal()))) {
    /**
     * 値に複数のハッシュアルゴリズムを適用させて結合して返す
     *
     * $data は何らかの方法で文字列化される（この「何らかの方法」は互換性を担保しない）。
     * 文字長がかなり増えるため、 $base64 に true を与えるとバイナリ変換してその結果を base64（url セーフ）して返す。
     * さらに false を与えると 16進数文字列で返し、 null を与えるとバイナリ文字列で返す。
     *
     * Example:
     * ```php
     * // 配列をハッシュ化する
     * that(var_hash(['a', 'b', 'c']))->isSame('7BDgx6NE2hkXAKtKzhpeJm6-mheMOQWNgrCe7768OiFeoWgA');
     * // オブジェクトをハッシュ化する
     * that(var_hash(new \ArrayObject(['a', 'b', 'c'])))->isSame('-zR2rZ58CzuYhhdHn1Oq90zkYSaxMS-dHUbmb0MTRM4gBpj2');
     * ```
     *
     * @param mixed $var ハッシュ化する値
     * @param string[] $algos ハッシュアルゴリズム
     * @param ?bool $base64 結果を base64 化するか
     * @return string ハッシュ文字列
     */
    function var_hash($var, $algos = ['md5', 'sha1'], $base64 = true)
    {
        if (!is_string($var)) {
            $var = serialize($var);
        }

        $algos = arrayize($algos);
        assert($algos);

        $hash = '';
        foreach ($algos as $algo) {
            $hash .= hash($algo, "$var", $base64 !== false);
        }

        if ($base64 !== true) {
            return $hash;
        }

        return rtrim(strtr(base64_encode($hash), ['+' => '-', '/' => '_']));
    }
}
if (function_exists("ryunosuke\\PHPUnit\\var_hash") && !defined("ryunosuke\\PHPUnit\\var_hash")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\var_hash", "ryunosuke\\PHPUnit\\var_hash");
}

if (!isset($excluded_functions["var_export2"]) && (!function_exists("ryunosuke\\PHPUnit\\var_export2") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\var_export2"))->isInternal()))) {
    /**
     * 組み込みの var_export をいい感じにしたもの
     *
     * 下記の点が異なる。
     *
     * - 配列は 5.4 以降のショートシンタックス（[]）で出力
     * - インデントは 4 固定
     * - ただの配列は1行（[1, 2, 3]）でケツカンマなし、連想配列は桁合わせインデントでケツカンマあり
     * - 文字列はダブルクオート
     * - null は null（小文字）
     * - 再帰構造を渡しても警告がでない（さらに NULL ではなく `'*RECURSION*'` という文字列になる）
     * - 配列の再帰構造の出力が異なる（Example参照）
     *
     * Example:
     * ```php
     * // 単純なエクスポート
     * that(var_export2(['array' => [1, 2, 3], 'hash' => ['a' => 'A', 'b' => 'B', 'c' => 'C']], true))->isSame('[
     *     "array" => [1, 2, 3],
     *     "hash"  => [
     *         "a" => "A",
     *         "b" => "B",
     *         "c" => "C",
     *     ],
     * ]');
     * // 再帰構造を含むエクスポート（標準の var_export は形式が異なる。 var_export すれば分かる）
     * $rarray = [];
     * $rarray['a']['b']['c'] = &$rarray;
     * $robject = new \stdClass();
     * $robject->a = new \stdClass();
     * $robject->a->b = new \stdClass();
     * $robject->a->b->c = $robject;
     * that(var_export2(compact('rarray', 'robject'), true))->isSame('[
     *     "rarray"  => [
     *         "a" => [
     *             "b" => [
     *                 "c" => "*RECURSION*",
     *             ],
     *         ],
     *     ],
     *     "robject" => (object) [
     *         "a" => (object) [
     *             "b" => (object) [
     *                 "c" => "*RECURSION*",
     *             ],
     *         ],
     *     ],
     * ]');
     * ```
     *
     * @param mixed $value 出力する値
     * @param bool $return 返すなら true 出すなら false
     * @return string|null $return=true の場合は出力せず結果を返す
     */
    function var_export2($value, $return = false)
    {
        // インデントの空白数
        $INDENT = 4;

        // 再帰用クロージャ
        $export = function ($value, $nest = 0, $parents = []) use (&$export, $INDENT) {
            // 再帰を検出したら *RECURSION* とする（処理に関しては is_recursive のコメント参照）
            foreach ($parents as $parent) {
                if ($parent === $value) {
                    return $export('*RECURSION*');
                }
            }
            // 配列は連想判定したり再帰したり色々
            if (is_array($value)) {
                $spacer1 = str_repeat(' ', ($nest + 1) * $INDENT);
                $spacer2 = str_repeat(' ', $nest * $INDENT);

                $hashed = is_hasharray($value);

                // スカラー値のみで構成されているならシンプルな再帰
                if (!$hashed && array_all($value, fn(...$args) => is_primitive(...$args))) {
                    return '[' . implode(', ', array_map($export, $value)) . ']';
                }

                // 連想配列はキーを含めて桁あわせ
                if ($hashed) {
                    $keys = array_map($export, array_combine($keys = array_keys($value), $keys));
                    $maxlen = max(array_map('strlen', $keys));
                }
                $kvl = '';
                $parents[] = $value;
                foreach ($value as $k => $v) {
                    $keystr = $hashed ? $keys[$k] . str_repeat(' ', $maxlen - strlen($keys[$k])) . ' => ' : '';
                    $kvl .= $spacer1 . $keystr . $export($v, $nest + 1, $parents) . ",\n";
                }
                return "[\n{$kvl}{$spacer2}]";
            }
            // オブジェクトは単にプロパティを __set_state する文字列を出力する
            elseif (is_object($value)) {
                $parents[] = $value;
                $classname = get_class($value);
                if ($classname === \stdClass::class) {
                    return '(object) ' . $export((array) $value, $nest, $parents);
                }
                return $classname . '::__set_state(' . $export(get_object_properties($value), $nest, $parents) . ')';
            }
            // 文字列はダブルクオート
            elseif (is_string($value)) {
                return '"' . addcslashes($value, "\$\"\0\\") . '"';
            }
            // null は小文字で居て欲しい
            elseif (is_null($value)) {
                return 'null';
            }
            // それ以外は標準に従う
            else {
                return var_export($value, true);
            }
        };

        // 結果を返したり出力したり
        $result = $export($value);
        if ($return) {
            return $result;
        }
        echo $result, "\n";
    }
}
if (function_exists("ryunosuke\\PHPUnit\\var_export2") && !defined("ryunosuke\\PHPUnit\\var_export2")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\var_export2", "ryunosuke\\PHPUnit\\var_export2");
}

if (!isset($excluded_functions["var_export3"]) && (!function_exists("ryunosuke\\PHPUnit\\var_export3") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\var_export3"))->isInternal()))) {
    /**
     * var_export を色々と出力できるようにしたもの
     *
     * php のコードに落とし込むことで serialize と比較してかなり高速に動作する。
     *
     * 各種オブジェクトやクロージャ、循環参照を含む配列など様々なものが出力できる。
     * ただし、下記は不可能あるいは復元不可（今度も対応するかは未定）。
     *
     * - Generator クラス
     * - 特定の内部クラス（PDO など）
     * - リソース
     * - アロー関数によるクロージャ
     *
     * オブジェクトは「リフレクションを用いてコンストラクタなしで生成してプロパティを代入する」という手法で復元する。
     * のでクラスによってはおかしな状態で復元されることがある（大体はリソース型のせいだが…）。
     * sleep, wakeup, Serializable などが実装されているとそれはそのまま機能する。
     * set_state だけは呼ばれないので注意。
     *
     * クロージャはコード自体を引っ張ってきて普通に function (){} として埋め込む。
     * クラス名のエイリアスや use, $this バインドなど可能な限り復元するが、おそらくあまりに複雑なことをしてると失敗する。
     *
     * 軽くベンチを取ったところ、オブジェクトを含まない純粋な配列の場合、serialize の 200 倍くらいは速い（それでも var_export の方が速いが…）。
     * オブジェクトを含めば含むほど遅くなり、全要素がオブジェクトになると serialize と同程度になる。
     * 大体 var_export:var_export3:serialize が 1:5:1000 くらい。
     *
     * @param mixed $value エクスポートする値
     * @param bool|array $return 返り値として返すなら true. 配列を与えるとオプションになる
     * @return string エクスポートされた文字列
     */
    function var_export3($value, $return = false)
    {
        // 原則として var_export に合わせたいのでデフォルトでは bool: false で単に出力するのみとする
        if (is_bool($return)) {
            $return = [
                'return' => $return,
            ];
        }
        $options = $return;
        $options += [
            'format'  => 'pretty', // pretty or minify
            'outmode' => null,     // null: 本体のみ, 'eval': return ...;, 'file': <?php return ...;
        ];
        $options['return'] ??= !!$options['outmode'];

        $var_manager = new class() {
            private $vars = [];
            private $refs = [];

            private function arrayHasReference($array)
            {
                foreach ($array as $k => $v) {
                    $ref = \ReflectionReference::fromArrayElement($array, $k);
                    if ($ref) {
                        return true;
                    }
                    if (is_array($v) && $this->arrayHasReference($v)) {
                        return true;
                    }
                }
                return false;
            }

            public function varId($var)
            {
                // オブジェクトは明確な ID が取れる（closure/object の区分けに処理的な意味はない）
                if (is_object($var)) {
                    $id = ($var instanceof \Closure ? 'closure' : 'object') . (spl_object_id($var) + 1);
                    $this->vars[$id] = $var;
                    return $id;
                }
                // 配列は明確な ID が存在しないので、貯めて検索して ID を振る（参照さえ含まなければ ID に意味はないので参照込みのみ）
                if (is_array($var) && $this->arrayHasReference($var)) {
                    $id = array_search($var, $this->vars, true);
                    if (!$id) {
                        $id = 'array' . (count($this->vars) + 1);
                    }
                    $this->vars[$id] = $var;
                    return $id;
                }
            }

            public function refId($array, $k)
            {
                static $ids = [];
                $ref = \ReflectionReference::fromArrayElement($array, $k);
                if ($ref) {
                    $refid = $ref->getId();
                    $ids[$refid] = ($ids[$refid] ?? count($ids) + 1);
                    $id = 'reference' . $ids[$refid];
                    $this->refs[$id] = $array[$k];
                    return $id;
                }
            }

            public function orphan()
            {
                foreach ($this->refs as $rid => $var) {
                    $vid = array_search($var, $this->vars, true);
                    yield $rid => [!!$vid, $vid, $var];
                }
            }
        };

        // 再帰用クロージャ
        $vars = [];
        $export = function ($value, $nest = 0) use (&$export, &$vars, $var_manager) {
            $spacer0 = str_repeat(" ", 4 * ($nest + 0));
            $spacer1 = str_repeat(" ", 4 * ($nest + 1));
            $raw_export = fn($v) => $v;
            $var_export = fn($v) => var_export($v, true);
            $neighborToken = function ($n, $d, $tokens) {
                for ($i = $n + $d; isset($tokens[$i]); $i += $d) {
                    if ($tokens[$i][0] !== T_WHITESPACE) {
                        return $tokens[$i];
                    }
                }
            };
            $resolveSymbol = function ($token, $prev, $next, $ref) use ($var_export) {
                if ($token[0] === T_STRING) {
                    if ($prev[0] === T_NEW || $next[0] === T_DOUBLE_COLON || $next[0] === T_VARIABLE || $next[1] === '{') {
                        $token[1] = resolve_symbol($token[1], $ref->getFileName(), 'alias') ?? $token[1];
                    }
                    elseif ($next[1] === '(') {
                        $token[1] = resolve_symbol($token[1], $ref->getFileName(), 'function') ?? $token[1];
                    }
                    else {
                        $token[1] = resolve_symbol($token[1], $ref->getFileName(), 'const') ?? $token[1];
                    }
                }

                // マジック定数の解決（__CLASS__, __TRAIT__ も書き換えなければならないが、非常に大変なので下記のみ）
                if ($token[0] === T_FILE) {
                    $token[1] = $var_export($ref->getFileName());
                }
                if ($token[0] === T_DIR) {
                    $token[1] = $var_export(dirname($ref->getFileName()));
                }
                if ($token[0] === T_NS_C) {
                    $token[1] = $var_export($ref->getNamespaceName());
                }
                return $token;
            };

            $vid = $var_manager->varId($value);
            if ($vid) {
                if (isset($vars[$vid])) {
                    return "\$this->$vid";
                }
                $vars[$vid] = $value;
            }

            if (is_array($value)) {
                $hashed = is_hasharray($value);
                if (!$hashed && array_all($value, fn(...$args) => is_primitive(...$args))) {
                    [$begin, $middle, $end] = ["", ", ", ""];
                }
                else {
                    [$begin, $middle, $end] = ["\n{$spacer1}", ",\n{$spacer1}", ",\n{$spacer0}"];
                }

                $keys = array_map($var_export, array_combine($keys = array_keys($value), $keys));
                $maxlen = max(array_map('strlen', $keys ?: ['']));
                $kvl = [];
                foreach ($value as $k => $v) {
                    $refid = $var_manager->refId($value, $k);
                    $keystr = $hashed ? $keys[$k] . str_repeat(" ", $maxlen - strlen($keys[$k])) . " => " : '';
                    $valstr = $refid ? "&\$this->$refid" : $export($v, $nest + 1);
                    $kvl[] = $keystr . $valstr;
                }
                $kvl = implode($middle, $kvl);
                $declare = $vid ? "\$this->$vid = " : "";
                return "{$declare}[$begin{$kvl}$end]";
            }
            if ($value instanceof \Closure) {
                $ref = new \ReflectionFunction($value);
                $bind = $ref->getClosureThis();
                $class = $ref->getClosureScopeClass() ? $ref->getClosureScopeClass()->getName() : null;
                $statics = $ref->getStaticVariables();

                // 内部由来はきちんと fromCallable しないと差異が出てしまう
                if ($ref->isInternal()) {
                    $receiver = $bind ?? $class;
                    $callee = $receiver ? [$receiver, $ref->getName()] : $ref->getName();
                    return "\$this->$vid = \\Closure::fromCallable({$export($callee, $nest)})";
                }

                [$meta, $body] = callable_code($value);
                $arrow = starts_with($meta, 'fn') ? ' => ' : ' ';
                $tokens = array_slice(parse_php("$meta{$arrow}$body;", TOKEN_PARSE), 1, -1);

                $uses = [];
                $context = [
                    'class' => 0,
                    'brace' => 0,
                ];
                foreach ($tokens as $n => $token) {
                    $prev = $neighborToken($n, -1, $tokens) ?? [null, null, null];
                    $next = $neighborToken($n, +1, $tokens) ?? [null, null, null];

                    // クロージャは何でもかける（クロージャ・無名クラス・ジェネレータ etc）のでネスト（ブレース）レベルを記録しておく
                    if ($token[1] === '{') {
                        $context['brace']++;
                    }
                    if ($token[1] === '}') {
                        $context['brace']--;
                    }

                    // 無名クラスは色々厄介なので読み飛ばすために覚えておく
                    if ($prev[0] === T_NEW && $token[0] === T_CLASS) {
                        $context['class'] = $context['brace'];
                    }
                    // そして無名クラスは色々かける上に終了条件が自明ではない（シンタックスエラーでない限りは {} が一致するはず）
                    if ($token[1] === '}' && $context['class'] === $context['brace']) {
                        $context['class'] = 0;
                    }

                    // fromCallable 由来だと名前がついてしまう
                    if (!$context['class'] && $prev[0] === T_FUNCTION && $token[0] === T_STRING) {
                        unset($tokens[$n]);
                        continue;
                    }

                    // use 変数の導出
                    if ($token[0] === T_VARIABLE) {
                        $varname = substr($token[1], 1);
                        // クロージャ内クロージャの use に反応してしまうので存在するときのみとする
                        if (array_key_exists($varname, $statics) && !isset($uses[$varname])) {
                            $recurself = $statics[$varname] === $value ? '&' : '';
                            $uses[$varname] = "$spacer1\$$varname = $recurself{$export($statics[$varname], $nest + 1)};\n";
                        }
                    }

                    $tokens[$n] = $resolveSymbol($token, $prev, $next, $ref);
                }

                $code = indent_php(implode('', array_column($tokens, 1)), [
                    'indent'   => $spacer1,
                    'baseline' => -1,
                ]);
                if ($bind) {
                    $scope = $var_export($class === 'Closure' ? 'static' : $class);
                    $code = "\Closure::bind($code, {$export($bind, $nest + 1)}, $scope)";
                }
                elseif (!is_bindable_closure($value)) {
                    $code = "static $code";
                }

                return "\$this->$vid = (function () {\n{$raw_export(implode('', $uses))}{$spacer1}return $code;\n$spacer0})->call(\$this)";
            }
            if (is_object($value)) {
                $ref = new \ReflectionObject($value);

                // ジェネレータはどう頑張っても無理
                if ($value instanceof \Generator) {
                    throw new \DomainException('Generator Class is not support.');
                }

                // 無名クラスは定義がないのでパースが必要
                // さらにコンストラクタを呼ぶわけには行かない（引数を検出するのは不可能）ので潰す必要もある
                if ($ref->isAnonymous()) {
                    $fname = $ref->getFileName();
                    $sline = $ref->getStartLine();
                    $eline = $ref->getEndLine();
                    $tokens = parse_php(implode('', array_slice(file($fname), $sline - 1, $eline - $sline + 1)));

                    $block = [];
                    $starting = false;
                    $constructing = 0;
                    $nesting = 0;
                    foreach ($tokens as $n => $token) {
                        $prev = $neighborToken($n, -1, $tokens) ?? [null, null, null];
                        $next = $neighborToken($n, +1, $tokens) ?? [null, null, null];

                        // 無名クラスは new class で始まるはず
                        if ($token[0] === T_NEW && $next[0] === T_CLASS) {
                            $starting = true;
                        }
                        if (!$starting) {
                            continue;
                        }

                        // コンストラクタの呼び出し引数はスキップする
                        if ($constructing !== null) {
                            if ($token[1] === '(') {
                                $constructing++;
                            }
                            if ($token[1] === ')') {
                                $constructing--;
                                if ($constructing === 0) {
                                    $constructing = null;          // null を終了済みマークとして変数を再利用している
                                    $block[] = [null, '()', null]; // for psr-12
                                    continue;
                                }
                            }
                            if ($constructing) {
                                continue;
                            }
                        }

                        // コンストラクタは呼ばないのでリネームしておく
                        if ($token[1] === '__construct') {
                            $token[1] = "replaced__construct";
                        }

                        $block[] = $resolveSymbol($token, $prev, $next, $ref);

                        if ($token[1] === '{') {
                            $nesting++;
                        }
                        if ($token[1] === '}') {
                            $nesting--;
                            if ($nesting === 0) {
                                break;
                            }
                        }
                    }

                    $code = indent_php(implode('', array_column($block, 1)), [
                        'indent'   => $spacer1,
                        'baseline' => -1,
                    ]);
                    $classname = "(function () {\n{$spacer1}return $code;\n{$spacer0}})";
                }
                else {
                    $classname = "\\" . get_class($value) . "::class";
                }

                $privates = [];

                // __serialize があるならそれに従う
                if (method_exists($value, '__serialize')) {
                    $fields = $value->__serialize();
                }
                // __sleep があるならそれをプロパティとする
                elseif (method_exists($value, '__sleep')) {
                    $fields = array_intersect_key(get_object_properties($value, $privates), array_flip($value->__sleep()));
                }
                // それ以外は適当に漁る
                else {
                    $fields = get_object_properties($value, $privates);
                }

                return "\$this->new(\$this->$vid, $classname, (function () {\n{$spacer1}return {$export([$fields, $privates], $nest + 1)};\n{$spacer0}}))";
            }

            return is_null($value) || is_resource($value) ? 'null' : $var_export($value);
        };

        $exported = $export($value, 1);
        $others = "";
        $vars = [];
        foreach ($var_manager->orphan() as $rid => [$isref, $vid, $var]) {
            $declare = $isref ? "&\$this->$vid" : $export($var, 1);
            $others .= "    \$this->$rid = $declare;\n";
        }
        $result = "(function () {
{$others}    return $exported;
" . '})->call(new class() {
    public function new(&$object, $class, $provider)
    {
        if ($class instanceof \\Closure) {
            $object = $class();
            $reflection = $this->reflect(get_class($object));
        }
        else {
            $reflection = $this->reflect($class);
            $object = $reflection["self"]->newInstanceWithoutConstructor();
        }
        [$fields, $privates] = $provider();

        if ($reflection["unserialize"]) {
            $object->__unserialize($fields);
            return $object;
        }

        foreach ($reflection["parents"] as $parent) {
            foreach ($this->reflect($parent->name)["properties"] as $name => $property) {
                if (isset($privates[$parent->name][$name])) {
                    $property->setValue($object, $privates[$parent->name][$name]);
                }
                if (isset($fields[$name]) || array_key_exists($name, $fields)) {
                    $property->setValue($object, $fields[$name]);
                    unset($fields[$name]);
                }
            }
        }
        foreach ($fields as $name => $value) {
            $object->$name = $value;
        }

        if ($reflection["wakeup"]) {
            $object->__wakeup();
        }

        return $object;
    }

    private function reflect($class)
    {
        static $cache = [];
        if (!isset($cache[$class])) {
            $refclass = new \ReflectionClass($class);
            $cache[$class] = [
                "self"        => $refclass,
                "parents"     => [],
                "properties"  => [],
                "unserialize" => $refclass->hasMethod("__unserialize"),
                "wakeup"      => $refclass->hasMethod("__wakeup"),
            ];
            for ($current = $refclass; $current; $current = $current->getParentClass()) {
                $cache[$class]["parents"][$current->name] = $current;
            }
            foreach ($refclass->getProperties() as $property) {
                if (!$property->isStatic()) {
                    $property->setAccessible(true);
                    $cache[$class]["properties"][$property->name] = $property;
                }
            }
        }
        return $cache[$class];
    }
})';

        if ($options['format'] === 'minify') {
            $tmp = memory_path('var_export3.php');
            file_put_contents($tmp, "<?php $result;");
            $result = substr(php_strip_whitespace($tmp), 6, -1);
        }

        if ($options['outmode'] === 'eval') {
            $result = "return $result;";
        }
        if ($options['outmode'] === 'file') {
            $result = "<?php return $result;\n";
        }

        if (!$options['return']) {
            echo $result;
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\PHPUnit\\var_export3") && !defined("ryunosuke\\PHPUnit\\var_export3")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\var_export3", "ryunosuke\\PHPUnit\\var_export3");
}

if (!isset($excluded_functions["var_pretty"]) && (!function_exists("ryunosuke\\PHPUnit\\var_pretty") || (!false && (new \ReflectionFunction("ryunosuke\\PHPUnit\\var_pretty"))->isInternal()))) {
    /**
     * var_dump の出力を見やすくしたもの
     *
     * var_dump はとても縦に長い上見づらいので色や改行・空白を調整して見やすくした。
     * sapi に応じて自動で色分けがなされる（$context で指定もできる）。
     * また、 xdebug のように呼び出しファイル:行数が先頭に付与される。
     *
     * この関数の出力は互換性を考慮しない。頻繁に変更される可能性がある。
     *
     * Example:
     * ```php
     * // 下記のように出力される（実際は色付きで出力される）
     * $using = 123;
     * var_pretty([
     *     "array"   => [1, 2, 3],
     *     "hash"    => [
     *         "a" => "A",
     *         "b" => "B",
     *         "c" => "C",
     *     ],
     *     "object"  => new \Exception(),
     *     "closure" => function () use ($using) { },
     * ]);
     * ?>
     * {
     *   array: [1, 2, 3],
     *   hash: {
     *     a: 'A',
     *     b: 'B',
     *     c: 'C',
     *   },
     *   object: Exception#1 {
     *     message: '',
     *     string: '',
     *     code: 0,
     *     file: '...',
     *     line: 19,
     *     trace: [],
     *     previous: null,
     *   },
     *   closure: Closure#0(static) use {
     *     using: 123,
     *   },
     * }
     * <?php
     * ```
     *
     * @param mixed $value 出力する値
     * @param array $options 出力オプション
     * @return string return: true なら値の出力結果
     */
    function var_pretty($value, $options = [])
    {
        $options += [
            'minify'    => false, // 短縮形で返す（実質的には情報を減らして1行で返す）
            'indent'    => 2,     // インデントの空白数
            'context'   => null,  // html なコンテキストか cli なコンテキストか
            'return'    => false, // 値を戻すか出力するか
            'trace'     => false, // スタックトレースの表示
            'callback'  => null,  // 値1つごとのコールバック（値と文字列表現（参照）が引数で渡ってくる）
            'debuginfo' => true,  // debugInfo を利用してオブジェクトのプロパティを絞るか
            'maxcolumn' => null,  // 1行あたりの文字数
            'maxcount'  => null,  // 複合型の要素の数
            'maxdepth'  => null,  // 複合型の深さ
            'maxlength' => null,  // スカラー・非複合配列の文字数
            'limit'     => null,  // 最終出力の文字数
        ];

        if ($options['context'] === null) {
            $options['context'] = 'html'; // SAPI でテストカバレッジが辛いので if else ではなくデフォルト代入にしてある
            if (PHP_SAPI === 'cli') {
                $options['context'] = is_ansi(STDOUT) && !$options['return'] ? 'cli' : 'plain';
            }
        }

        if ($options['minify']) {
            $options['indent'] = null;
            $options['trace'] = false;
        }

        $appender = new class($options) {
            private $options;
            private $objects;
            private $content;
            private $length;
            private $column;

            public function __construct($options)
            {
                $this->options = $options;
                $this->objects = [];
                $this->content = '';
                $this->length = 0;
                $this->column = 0;
            }

            private function _append($value, $style = null, $data = []): self
            {
                if ($this->options['minify']) {
                    $value = strtr($value, ["\n" => ' ']);
                }

                $strlen = strlen($value);

                if ($this->options['limit'] && $this->options['limit'] < $this->length += $strlen) {
                    throw new \LengthException($this->content);
                }

                //$current = count($this->content) - 1;
                if ($this->options['maxcolumn'] !== null) {
                    $breakpos = strrpos($value, "\n");
                    if ($breakpos === false) {
                        $this->column += $strlen;
                    }
                    else {
                        $this->column = $strlen - $breakpos - 1;
                    }
                    if ($this->column >= $this->options['maxcolumn']) {
                        preg_match('# +#', $this->content, $m, 0, strrpos($this->content, "\n"));
                        $this->column = 0;
                        $this->content .= "\n\t" . $m[0];
                    }
                }

                if ($style === null || $this->options['context'] === 'plain') {
                    $this->content .= $value;
                }
                elseif ($this->options['context'] === 'cli') {
                    $this->content .= ansi_colorize($value, $style);
                }
                elseif ($this->options['context'] === 'html') {
                    // 今のところ bold しか使っていないのでこれでよい
                    $style = $style === 'bold' ? 'font-weight:bold' : "color:$style";
                    $dataattr = array_sprintf($data, 'data-%2$s="%1$s"', ' ');
                    $this->content .= "<span style='$style' $dataattr>" . htmlspecialchars($value, ENT_QUOTES) . '</span>';
                }
                else {
                    throw new \InvalidArgumentException("'{$this->options['context']}' is not supported.");
                }
                return $this;
            }

            public function plain($token): self
            {
                return $this->_append($token);
            }

            public function index($token): self
            {
                if (is_int($token)) {
                    return $this->_append($token, 'bold');
                }
                elseif (is_string($token)) {
                    return $this->_append($token, 'red');
                }
                elseif (is_object($token)) {
                    return $this->_append($this->string($token), 'green', ['type' => 'object-index', 'id' => spl_object_id($token)]);
                }
                else {
                    throw new \DomainException(); // @codeCoverageIgnore
                }
            }

            public function value($token): self
            {
                if (is_null($token)) {
                    return $this->_append($this->string($token), 'bold', ['type' => 'null']);
                }
                elseif (is_object($token)) {
                    return $this->_append($this->string($token), 'green', ['type' => 'object', 'id' => spl_object_id($token)]);
                }
                elseif (is_resource($token)) {
                    return $this->_append($this->string($token), 'bold', ['type' => 'resource']);
                }
                elseif (is_string($token)) {
                    return $this->_append($this->string($token), 'magenta', ['type' => 'scalar']);
                }
                elseif (is_bool($token)) {
                    return $this->_append($this->string($token), 'bold', ['type' => 'bool']);
                }
                elseif (is_scalar($token)) {
                    return $this->_append($this->string($token), 'magenta', ['type' => 'scalar']);
                }
                else {
                    throw new \DomainException(); // @codeCoverageIgnore
                }
            }

            public function string($token): string
            {
                if (is_null($token)) {
                    return 'null';
                }
                elseif (is_object($token)) {
                    if ($token instanceof \Closure) {
                        $ref = new \ReflectionFunction($token);
                        $fname = $ref->getFileName();
                        $sline = $ref->getStartLine();
                        $eline = $ref->getEndLine();
                        if ($fname && $sline && $eline) {
                            $lines = $sline === $eline ? $sline : "$sline~$eline";
                            return get_class($token) . "@$fname:$lines#" . spl_object_id($token);
                        }
                    }
                    return get_class($token) . "#" . spl_object_id($token);
                }
                elseif (is_resource($token)) {
                    return sprintf('%s of type (%s)', $token, get_resource_type($token));
                }
                elseif (is_string($token)) {
                    if ($this->options['maxlength']) {
                        $token = str_ellipsis($token, $this->options['maxlength'], '...(too length)...');
                    }
                    return json_encode($token, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
                }
                elseif (is_scalar($token)) {
                    return var_export($token, true);
                }
                else {
                    throw new \DomainException(gettype($token)); // @codeCoverageIgnore
                }
            }

            public function export($value, $nest, $parents, $callback)
            {
                $position = strlen($this->content);

                // オブジェクトは一度処理してれば無駄なので参照表示
                if (is_object($value)) {
                    $id = spl_object_id($value);
                    if (isset($this->objects[$id])) {
                        $this->index($value);
                        goto FINALLY_;
                    }
                    $this->objects[$id] = $value;
                }

                // 再帰を検出したら *RECURSION* とする（処理に関しては is_recursive のコメント参照）
                foreach ($parents as $parent) {
                    if ($parent === $value) {
                        $this->plain('*RECURSION*');
                        goto FINALLY_;
                    }
                }

                if (is_array($value)) {
                    if ($this->options['maxdepth'] && $nest + 1 > $this->options['maxdepth']) {
                        $this->plain('(too deep)');
                        goto FINALLY_;
                    }

                    $parents[] = $value;

                    $count = count($value);
                    $omitted = false;
                    if ($this->options['maxcount'] && ($omitted = $count - $this->options['maxcount']) > 0) {
                        $value = array_slice($value, 0, $this->options['maxcount'], true);
                    }

                    $is_hasharray = is_hasharray($value);
                    $primitive_only = array_all($value, fn(...$args) => is_primitive(...$args));
                    $assoc = !$this->options['minify'] && ($is_hasharray || !$primitive_only);

                    $spacer1 = $this->options['indent'] === null ? '' : str_repeat(' ', ($nest + 1) * $this->options['indent']);
                    $spacer2 = $this->options['indent'] === null ? '' : str_repeat(' ', ($nest + 0) * $this->options['indent']);

                    $key = null;
                    if ($primitive_only && $this->options['maxlength']) {
                        $lengths = [];
                        foreach ($value as $k => $v) {
                            if ($assoc) {
                                $lengths[] = strlen($this->string($spacer1)) + strlen($this->string($k)) + strlen($this->string($v)) + 4;
                            }
                            else {
                                $lengths[] = strlen($this->string($v)) + 2;
                            }
                        }
                        while (count($lengths) > 0 && array_sum($lengths) > $this->options['maxlength']) {
                            $middle = (int) (count($lengths) / 2);
                            $unpos = fn($v, $k, $n) => $n === $middle;
                            array_unset($value, $unpos);
                            array_unset($lengths, $unpos);
                            $key = (int) (count($lengths) / 2);
                        }
                    }

                    if ($count === 0) {
                        $this->plain('[]');
                    }
                    elseif ($assoc) {
                        $n = 0;
                        if ($is_hasharray) {
                            $this->plain("{\n");
                        }
                        else {
                            $this->plain("[\n");
                        }
                        if (!$value) {
                            $this->plain($spacer1)->plain('...(too length)...')->plain(",\n");
                        }
                        foreach ($value as $k => $v) {
                            if ($key === $n++) {
                                $this->plain($spacer1)->plain('...(too length)...')->plain(",\n");
                            }
                            $this->plain($spacer1);
                            if ($is_hasharray) {
                                $this->index($k)->plain(': ');
                            }
                            $this->export($v, $nest + 1, $parents, true);
                            $this->plain(",\n");
                        }
                        if ($omitted > 0) {
                            $this->plain("$spacer1(more $omitted elements)\n");
                        }
                        if ($is_hasharray) {
                            $this->plain("{$spacer2}}");
                        }
                        else {
                            $this->plain("{$spacer2}]");
                        }
                    }
                    else {
                        $lastkey = last_key($value);
                        $n = 0;
                        $this->plain('[');
                        if (!$value) {
                            $this->plain('...(too length)...')->plain(', ');
                        }
                        foreach ($value as $k => $v) {
                            if ($key === $n) {
                                $this->plain('...(too length)...')->plain(', ');
                            }
                            if ($is_hasharray && $n !== $k) {
                                $this->index($k)->plain(':');
                            }
                            $this->export($v, $nest, $parents, true);
                            if ($k !== $lastkey) {
                                $this->plain(', ');
                            }
                            $n++;
                        }
                        if ($omitted > 0) {
                            $this->plain(" (more $omitted elements)");
                        }
                        $this->plain(']');
                    }
                }
                elseif ($value instanceof \Closure) {
                    $this->value($value);

                    if ($this->options['minify']) {
                        goto FINALLY_;
                    }

                    $ref = reflect_callable($value);
                    $that = $ref->getClosureThis();
                    $properties = $ref->getStaticVariables();

                    $this->plain("(");
                    if ($that) {
                        $this->index($that);
                    }
                    else {
                        $this->plain("static");
                    }
                    $this->plain(') use ');
                    if ($properties) {
                        $this->export($properties, $nest, $parents, false);
                    }
                    else {
                        $this->plain('{}');
                    }
                }
                elseif (is_object($value)) {
                    $this->value($value);

                    if ($this->options['minify']) {
                        goto FINALLY_;
                    }

                    if ($this->options['debuginfo'] && method_exists($value, '__debugInfo')) {
                        $properties = [];
                        foreach (array_reverse($value->__debugInfo(), true) as $k => $v) {
                            $p = strrpos($k, "\0");
                            if ($p !== false) {
                                $k = substr($k, $p + 1);
                            }
                            $properties[$k] = $v;
                        }
                    }
                    else {
                        $properties = get_object_properties($value);
                    }

                    $this->plain(" ");
                    if ($properties) {
                        $this->export($properties, $nest, $parents, false);
                    }
                    else {
                        $this->plain('{}');
                    }
                }
                else {
                    $this->value($value);
                }

                FINALLY_:
                $content = substr($this->content, $position);
                if ($callback && $this->options['callback']) {
                    ($this->options['callback'])($content, $value, $nest);
                    $this->content = substr_replace($this->content, $content, $position);
                }
                return $content;
            }
        };

        try {
            $content = $appender->export($value, 0, [], false);
        }
        catch (\LengthException $ex) {
            $content = $ex->getMessage() . '(...omitted)';
        }

        if ($options['callback']) {
            ($options['callback'])($content, $value, 0);
        }

        // 結果を返したり出力したり
        $traces = [];
        if ($options['trace']) {
            $traces = stacktrace(null, ['format' => "%s:%s", 'args' => false, 'delimiter' => null]);
            $traces = array_reverse(array_slice($traces, 0, $options['trace'] === true ? null : $options['trace']));
            $traces[] = '';
        }
        $result = implode("\n", $traces) . $content;

        if ($options['context'] === 'html') {
            $result = "<pre class='var_pretty'>$result</pre>";
        }
        if ($options['return']) {
            return $result;
        }
        echo $result, "\n";
    }
}
if (function_exists("ryunosuke\\PHPUnit\\var_pretty") && !defined("ryunosuke\\PHPUnit\\var_pretty")) {
    /**
     *
     */
    define("ryunosuke\\PHPUnit\\var_pretty", "ryunosuke\\PHPUnit\\var_pretty");
}
